<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="在 Pistacho 发布雪茄点评，记录口感、评分与照片，与全球雪茄爱好者分享你的独到见解。">
    <meta name="keywords" content="Pistacho, 发布点评, 雪茄评分, 雪茄分享, 雪茄体验">
    <meta name="robots" content="index, follow">
    <meta property="og:title" content="发布雪茄点评 - Pistacho">
    <meta property="og:description" content="使用 Pistacho 雪茄评分工具发布专业点评、上传照片并管理品鉴记录。">
    <meta property="og:type" content="website">
    <meta property="og:image" content="Certifiedstamp.png">
    <meta property="og:locale" content="zh_CN">
    <meta name="twitter:card" content="summary_large_image">
    <title data-i18n="ratePage.title">发布雪茄点评</title>
    <link rel="icon" type="image/png" href="Certifiedstamp.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>

    <script src="https://unpkg.com/i18next/i18next.min.js"></script>
    <script src="https://unpkg.com/i18next-http-backend/i18nextHttpBackend.min.js"></script>
    <script src="https://unpkg.com/i18next-browser-languagedetector/i18nextBrowserLanguageDetector.min.js"></script>
    <script type="module" src="scripts/navbar.js"></script>

    <script>
        // Tailwind config
        if (typeof tailwind !== 'undefined') {
            tailwind.config = {
                theme: {
                    extend: {
                        fontFamily: { sans: ['Inter', 'Noto Sans SC', 'system-ui', 'sans-serif'], },
                        transitionProperty: { 'width': 'width' }
                    }
                }
            }
        } else { console.warn('Tailwind object not found. Skipping config.'); }
    </script>
    <style>
        /* Language switcher buttons */
        .lang-button {
            padding: 2px 8px;
            margin: 0 2px;
            border: 1px solid transparent;
            border-radius: 9999px;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 600;
            background-color: #f3f4f6;
            color: #374151;
            transition: all 0.2s ease;
        }
        .lang-button:hover {
            background-color: #e5e7eb;
        }
        .lang-button.active {
            background-color: #e0e7ff;
            border-color: #a5b4fc;
            color: #3730a3;
            cursor: default;
        }

        /* Tooltip style (if needed, otherwise remove) */
        .tooltip { position: relative; display: inline-block; }
        .tooltip .tooltiptext { visibility: hidden; width: 60px; background-color: #555; color: #fff; text-align: center; border-radius: 6px; padding: 5px 0; position: absolute; z-index: 1; bottom: 125%; left: 50%; margin-left: -30px; opacity: 0; transition: opacity 0.3s; font-size: 10px; }
        .tooltip .tooltiptext::after { content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: #555 transparent transparent transparent; }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }
        /* Cropper modal styles */
        .cropper-container { max-height: 60vh; }
        .cropper-modal-content { width: 90%; max-width: 800px; }
        /* Preview grid and item styles */
        .preview-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(96px, 1fr)); gap: 0.75rem; }
        .preview-item {
            position: relative; aspect-ratio: 1179 / 1572; overflow: hidden; border-radius: 0.375rem; /* rounded-md */
            border: 1px solid #e5e7eb; /* border-gray-200 */
            cursor: grab; /* Add grab cursor for draggable items */
            display: flex; align-items: center; justify-content: center; background-color: #f9fafb;
        }
        .preview-item:active { cursor: grabbing; } /* Change cursor while dragging */
        .preview-item img { display: block; max-width: 100%; max-height: 100%; object-fit: contain; }
        .preview-item .remove-btn { position: absolute; top: 2px; right: 2px; background-color: rgba(0,0,0,0.6); color: white; border: none; border-radius: 50%; width: 1.25rem; height: 1.25rem; font-size: 0.75rem; line-height: 1; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; z-index: 10; }
        .preview-item .remove-btn:hover { background-color: rgba(239, 68, 68, 0.8); /* hover:bg-red-500 */ }
        /* Style for "Set Cover" button */
        .preview-item .set-cover-btn {
            position: absolute; bottom: 2px; left: 2px; background-color: rgba(0, 0, 0, 0.6); color: white; border: none; border-radius: 0.25rem; /* rounded-sm */
            padding: 1px 4px; font-size: 0.65rem; /* Smaller text */ line-height: 1; cursor: pointer; z-index: 10;
        }
        .preview-item .set-cover-btn:hover { background-color: rgba(67, 56, 202, 0.8); /* hover:bg-indigo-700 */ }
        .preview-item.is-cover .set-cover-btn { /* Style for the current cover */
            background-color: rgba(22, 163, 74, 0.8); /* bg-green-600 */ cursor: default; pointer-events: none; /* Disable click */
        }
        /* Style for the element being dragged */
        .sortable-ghost { opacity: 0.4; background: #c8ebfb; }
        .sortable-drag { opacity: 1 !important; /* Ensure dragged item is fully visible */ }
        /* Style for flavor buttons */
        .flavor-btn {
            padding: 0.375rem 0.75rem; /* px-3 py-1.5 */
            border: 1px solid #d1d5db; /* border-gray-300 */
            border-radius: 9999px; /* rounded-full */
            font-size: 0.875rem; /* text-sm */
            margin-right: 0.5rem; /* mr-2 */
            margin-bottom: 0.5rem; /* mb-2 */
            cursor: pointer;
            transition: all 0.2s;
            background-color: white;
            color: #374151; /* text-gray-700 */
        }
        .flavor-btn:hover:not(.selected) { /* Apply hover only if not selected */
            background-color: #f3f4f6; /* bg-gray-100 */
            border-color: #9ca3af; /* border-gray-400 */
        }
        .flavor-btn.selected {
            background-color: #4f46e5; /* bg-indigo-600 */
            color: white;
            border-color: #4f46e5; /* border-indigo-600 */
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        @media (max-width: 640px) {
            body { font-size: 0.95rem; }
            .preview-grid { grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 0.5rem; }
            .cropper-modal-content { width: 100%; max-width: 360px; padding: 1.5rem; }
            .cropper-container { max-height: 50vh; }
            .flavor-btn { padding: 0.35rem 0.65rem; font-size: 0.8rem; margin-right: 0.4rem; }
        }
    </style>
</head>
<body class="bg-gray-100 font-sans antialiased text-gray-800">
    <div class="px-4 sm:px-6 lg:px-8 pt-4">
        <div class="mx-auto max-w-7xl">
            <div data-include-nav data-active="rate" data-language="flags"></div>
        </div>
    </div>
    <div id="app-container" class="max-w-4xl mx-auto p-4 md:p-8">
        <!-- Header with Score Display -->
        <header class="mb-6 sm:mb-8 p-4 sm:p-6 bg-indigo-700 text-white rounded-xl shadow-2xl">
             <div class="flex flex-col gap-4 sm:flex-row sm:justify-between sm:items-start">
                 <div> <h1 id="app-title-display" class="text-2xl sm:text-3xl font-extrabold mb-1">雪茄评分应用</h1> <p id="app-description-display" class="text-indigo-200 text-sm max-w-lg">正在加载描述...</p> </div>
                 <div class="flex items-center gap-2 flex-wrap sm:flex-nowrap sm:justify-end"> <div id="admin-links-container" class="flex items-center gap-2"></div> </div>
             </div>
             <!-- Score and Progress Bar -->
             <div class="mt-4 sm:mt-6 bg-black bg-opacity-20 p-4 rounded-lg">
                 <div class="flex flex-col gap-4 sm:flex-row sm:items-end sm:justify-between">
                     <div>
                        <p class="text-sm font-medium text-indigo-200" data-i18n="ratePage.currentScore">当前得分</p>
                        <div class="flex items-baseline"> <span id="current-score-display" class="text-4xl sm:text-6xl font-black leading-none">0.00</span> <span class="text-base sm:text-lg font-medium text-indigo-200 ml-2">/ <span id="total-weight-max-display">0</span></span> </div>
                     </div>
                     <div class="text-right sm:text-right">
                        <p class="text-sm font-medium text-indigo-200" data-i18n="ratePage.itemsRated">已评项目</p>
                        <p id="progress-text" class="font-bold text-base sm:text-lg">0 / 0</p>
                     </div>
                 </div>
                 <div class="w-full bg-indigo-900 rounded-full h-2.5 mt-2"> <div id="progress-bar" class="bg-green-400 h-2.5 rounded-full transition-width duration-500" style="width: 0%"></div> </div>
             </div>
              <p id="config-load-status" class="text-xs text-yellow-300 mt-2 text-right" data-i18n="ratePage.configSyncing">正在连接...</p>
        </header>

        <!-- Login Prompt (hidden if logged in) -->
        <div id="login-prompt" class="hidden text-center p-6 bg-yellow-100 text-yellow-800 rounded-lg shadow mb-8">
             <p class="font-semibold mb-3" data-i18n="ratePage.loginPrompt">请先登录才能进行评分。</p>
             <button onclick="login()" class="px-5 py-2 text-sm font-medium rounded-lg bg-green-500 text-white hover:bg-green-600" data-i18n="nav.login">前往登录/注册</button>
        </div>


        <!-- Main Content (hidden if not logged in) -->
        <main id="main-content">

            <!-- Rating Title Section -->
            <section class="mb-6 sm:mb-8 p-4 sm:p-6 bg-white rounded-xl shadow-lg">
                <h2 class="text-xl font-bold text-gray-800 mb-4" data-i18n="ratePage.ratingTitle">点评标题 <span class="text-red-500">*</span></h2>
                <input type="text" id="rating-title" maxlength="35" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 focus:border-indigo-500 focus:ring-indigo-500" data-i18n="ratePage.ratingTitlePlaceholder" placeholder="填写标题会被更多人看到 (最多35字)">
                <p id="title-char-count" class="text-xs text-gray-500 text-right mt-1">0 / 35</p>
            </section>

            <!-- Image Upload Section -->
            <section class="mb-6 sm:mb-8 p-4 sm:p-6 bg-white rounded-xl shadow-lg">
                <h2 class="text-xl font-bold text-gray-800 mb-4" data-i18n="ratePage.uploadImages" data-i18n-options='{ "max": 5 }'>上传图片 (最多5张, 可拖拽排序) <span class="text-red-500">*</span></h2>
                <p class="text-sm text-gray-600 mb-3" data-i18n="ratePage.uploadImagesDesc">第一张图片将作为封面图显示。点击图片左下角按钮更换封面。</p>
                <div class="preview-grid mb-4" id="image-preview-grid">
                    <!-- Image previews will be rendered here -->
                </div>
                <div>
                    <label for="image-upload-input" id="image-upload-label" class="w-full md:w-auto text-center py-2 px-6 bg-blue-600 text-white font-bold rounded-lg shadow-md hover:bg-blue-700 cursor-pointer inline-block" data-i18n="ratePage.selectImages">
                        选择图片
                    </label>
                    <input type="file" id="image-upload-input" class="sr-only" accept="image/png, image/jpeg, image/webp" multiple onchange="handleFileSelect(event)">
                    <p class="text-sm text-gray-500 mt-2 inline-block md:ml-4" data-i18n="ratePage.imageSupport">支持 JPG, PNG, WEBP。单张最大 5MB。</p>
                    <p id="image-upload-status" class="text-sm font-medium text-indigo-600 mt-2"></p>
                </div>
            </section>

            <!-- Review and Flavors Section -->
            <section class="mb-6 sm:mb-8 p-4 sm:p-6 bg-white rounded-xl shadow-lg">
                <h2 class="text-xl font-bold text-gray-800 mb-4" data-i18n="ratePage.reviewAndFlavors">文字评价与风味选择</h2>
                <!-- Flavor Buttons -->
                <div class="mb-4 border-b pb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2" data-i18n="ratePage.selectFlavors">选择您感受到的主要风味 (可选):</label>
                    <div id="flavor-buttons-container" class="flex flex-wrap">
                        <!-- Flavor buttons will be rendered here -->
                    </div>
                </div>
                <!-- Detailed Review Textarea -->
                <div>
                    <label for="cigar-review" class="block text-sm font-medium text-gray-700 mb-2" data-i18n="ratePage.detailedReview">详细文字评价:</label>
                    <textarea id="cigar-review" rows="6" maxlength="1500" class="w-full p-3 border rounded-md focus:border-indigo-500 focus:ring-indigo-500" data-i18n="ratePage.reviewPlaceholder" placeholder="在此处输入您的详细品吸感受..."></textarea>
                    <p id="review-char-count" class="text-xs text-gray-500 text-right mt-1">0 / 1500</p>
                </div>
            </section>

            <!-- Cigar Information Section -->
            <section class="mb-6 sm:mb-8 p-4 sm:p-6 bg-white rounded-xl shadow-lg">
                <h2 class="text-xl font-bold text-gray-800 mb-4" data-i18n="ratePage.cigarInfo">雪茄信息</h2>
                 <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <div>
                        <label for="cigar-name" class="block text-sm font-medium text-gray-700" data-i18n="ratePage.cigarNameRequired">名称 <span class="text-red-500">*</span></label>
                        <input type="text" id="cigar-name" autocomplete="off" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2" data-i18n="ratePage.cigarNamePlaceholder" placeholder="例如：帕特加斯D4">
                    </div>
                    <div>
                        <label for="cigar-size" class="block text-sm font-medium text-gray-700" data-i18n="ratePage.cigarSize">尺寸</label>
                        <input type="text" id="cigar-size" autocomplete="off" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2" data-i18n="ratePage.cigarSizePlaceholder" placeholder="例如：Robusto">
                    </div>
                    <div>
                        <label for="cigar-origin" class="block text-sm font-medium text-gray-700" data-i18n="ratePage.cigarOrigin">产地</label>
                        <input type="text" id="cigar-origin" autocomplete="off" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2" data-i18n="ratePage.cigarOriginPlaceholder" placeholder="例如：古巴">
                    </div>
                 </div>
            </section>

            <!-- Dynamic Rating Form Container -->
            <div id="rating-form-container">
                <!-- Rating criteria will be rendered here by JS -->
            </div>

            <!-- Action Buttons -->
            <div class="mt-8 grid grid-cols-1 sm:grid-cols-2 gap-3 sm:gap-4">
                <button onclick="resetRatings()" class="w-full py-3 px-6 bg-red-500 text-white font-bold text-base sm:text-lg rounded-lg shadow-md hover:bg-red-600" data-i18n="ratePage.reset">重置</button>
                <button id="main-action-button" onclick="showResults()" class="w-full py-3 px-6 bg-green-600 text-white font-bold text-base sm:text-lg rounded-lg shadow-md hover:bg-green-700" data-i18n="ratePage.viewReport">查看报告</button>
            </div>
        </main>

        <footer class="mt-8 text-center text-gray-500 text-sm p-4 border-t">评分应用数据由云端配置中心实时同步。</footer>
    </div>

    <!-- Cropper Modal -->
    <div id="cropper-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
         <div class="bg-white rounded-lg shadow-xl p-6 cropper-modal-content">
            <h2 class="text-2xl font-bold mb-4" data-i18n="ratePage.cropImage">裁切图片</h2>
            <div class="cropper-container"> <img id="cropper-image" src="" alt="Image to crop"> </div>
            <p id="cropper-status" class="text-sm font-medium text-indigo-600 my-2"></p>
            <div class="flex justify-end gap-4 mt-4">
                <button onclick="cancelCrop()" class="py-2 px-5 bg-gray-300 text-gray-800 rounded-lg hover:bg-gray-400" data-i18n="common.cancel">取消</button>
                <button onclick="confirmCropAndUpload()" class="py-2 px-5 bg-blue-600 text-white rounded-lg hover:bg-blue-700" data-i18n="ratePage.cropAndUpload">确认并上传</button>
            </div>
         </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.js"></script>

    <script type="module">
        // --- i18n Functions ---
        async function initI18n() {
            // Initialize i18next with backend and language detector
            await i18next
                .use(i18nextHttpBackend)
                .use(i18nextBrowserLanguageDetector)
                .init({
                    fallbackLng: 'zh',
                    debug: false, // Turn off debug for production/less console noise
                    ns: ['translation'],
                    defaultNS: 'translation',
                    backend: {
                        loadPath: '/locales/{{lng}}.json?v=1' // Add cache busting
                    },
                    detection: {
                        order: ['localStorage', 'navigator'],
                        caches: ['localStorage']
                    }
                });
            updateContent(); // Initial content update after init
        }

        function updateContent() {
             // Update static elements with data-i18n attribute
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                const options = el.dataset.i18nOptions ? JSON.parse(el.dataset.i18nOptions) : undefined;
                let value = '';
                try {
                     value = i18next.t(key, options);
                     if (value === key && key !== '') console.warn(`Translation missing for key: ${key}`);
                } catch (e) { console.error(`Error translating key "${key}":`, e); value = `[Error: ${key}]`; }

                if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
                    if (el.type !== 'file' && el.hasAttribute('placeholder')) el.placeholder = value;
                } else if (el.tagName === 'OPTION') {
                    el.textContent = value;
                } else {
                    el.innerHTML = value; // Use innerHTML for most elements
                }
            });
            // Update document title dynamically based on edit mode
            const titleKey = isEditMode ? 'ratePage.editTitle' : 'ratePage.title';
            document.title = i18next.t(titleKey);
        }

        function renderLanguageSwitcher() {
            const container = document.getElementById('language-flags');
            if (!container || !i18next.isInitialized) return;
            container.innerHTML = '';
            const languages = ['zh', 'en', 'es'];
            const currentLang = i18next.language ? i18next.language.split('-')[0] : 'zh';

            languages.forEach(lang => {
                const button = document.createElement('button');
                button.textContent = lang.toUpperCase();
                button.className = `lang-button ${lang === currentLang ? 'active' : ''}`;
                button.dataset.lang = lang;
                button.onclick = async (e) => {
                    const newLang = e.target.dataset.lang;
                    const oldLang = i18next.language ? i18next.language.split('-')[0] : 'zh';
                    if (newLang === oldLang) return;
                    try {
                        await i18next.changeLanguage(newLang);
                        updateContent();
                        renderLanguageSwitcher();
                        renderRatingView();
                        renderLoginStatus(currentAuthUser);
                        renderAdminLinks();
                        renderFlavorButtons();
                    } catch (langErr) {
                        console.error(`Failed to change language to ${newLang}:`, langErr);
                    }
                };
                container.appendChild(button);
            });
        }
        // --- End i18n Functions ---

        // --- Global Variables ---
        let ratingConfig = null;        // Stores the rating configuration loaded from API
        let userRatings = {};           // Stores user's selections { "categoryKey-criterionKey": optionIndex }
        let currentAuthUser = null;     // Stores logged-in user info from Authing/API
        let currentImageKeys = [];      // Array of uploaded image keys (UUIDs) from R2
        let sortableInstance = null;    // Instance of SortableJS for image reordering
        let isEditMode = false;         // Flag indicating if the page is in edit mode
        let editRatingId = null;        // ID of the rating being edited
        let cropper = null;             // Cropper.js instance
        let selectedFlavors = [];       // Array of selected flavor i18n keys
        const mobileViewportMatcher = window.matchMedia('(max-width: 640px)');
        let preferCompactApiPayload = mobileViewportMatcher.matches;

        const updateCompactPreference = (event) => {
            preferCompactApiPayload = event.matches;
        };
        if (typeof mobileViewportMatcher.addEventListener === 'function') {
            mobileViewportMatcher.addEventListener('change', updateCompactPreference);
        } else if (typeof mobileViewportMatcher.addListener === 'function') {
            mobileViewportMatcher.addListener(updateCompactPreference);
        }

        const formatIntegerScore = (value) => {
            return typeof value === 'number' && !Number.isNaN(value)
                ? Math.trunc(value).toString()
                : '0';
        };

        function shouldUseCompactApiPayload() {
            return preferCompactApiPayload;
        }

        // DOM Element References (cached for performance)
        const cropperModal = document.getElementById('cropper-modal');
        const cropperImage = document.getElementById('cropper-image');
        const cropperStatus = document.getElementById('cropper-status');
        const titleInput = document.getElementById('rating-title');
        const titleCharCount = document.getElementById('title-char-count');
        const reviewTextarea = document.getElementById('cigar-review');
        const reviewCharCount = document.getElementById('review-char-count');
        const imageGrid = document.getElementById('image-preview-grid');
        const mainActionButton = document.getElementById('main-action-button');

        // Constants
        const AUTHING_APP_ID = '68f5b0b6875017c02b3bfdb3'; // Authing Application ID
        const AUTHING_HOST = 'https://xfvu647mcdbk-demo.authing.cn'; // Authing Host URL
        const GRADING_SCALE = [ // Defines score ranges and i18n keys for grades
            { "grade": "P", "nameKey": "resultsPage.grade.P", "min_score": 95, "color": "gold" },
            { "grade": "I", "nameKey": "resultsPage.grade.I", "min_score": 90, "color": "indigo" },
            { "grade": "S", "nameKey": "resultsPage.grade.S", "min_score": 80, "color": "purple" },
            { "grade": "T", "nameKey": "resultsPage.grade.T", "min_score": 70, "color": "blue" },
            { "grade": "A", "nameKey": "resultsPage.grade.A", "min_score": 60, "color": "green" },
            { "grade": "C", "nameKey": "resultsPage.grade.C", "min_score": 50, "color": "gray" },
            { "grade": "H", "nameKey": "resultsPage.grade.H", "min_score": 30, "color": "orange" },
            { "grade": "O", "nameKey": "resultsPage.grade.O", "min_score": 0, "color": "red" }
        ];
        const FLAVOR_KEYS = [ // i18n keys for flavor options
             "flavors.coffee", "flavors.chocolate", "flavors.cedar", "flavors.earth",
             "flavors.hay", "flavors.leather", "flavors.nuts", "flavors.spice",
             "flavors.wood", "flavors.sweetness", "flavors.cream", "flavors.floral",
             "flavors.fruit", "flavors.caramel", "flavors.vanilla", "flavors.citrus"
        ];
        const TITLE_MAX_LENGTH = 35;

        if (titleInput) {
            titleInput.maxLength = TITLE_MAX_LENGTH;
        }


        // --- Authentication ---
        // Initiates Authing login process
        window.login = function() {
            const redirectUri = window.location.origin; // Use base origin for redirect
            const authorizeUrl = new URL('/oidc/auth', AUTHING_HOST);
            authorizeUrl.search = new URLSearchParams({
                client_id: AUTHING_APP_ID,
                redirect_uri: redirectUri, // Pass base origin
                response_type: 'code',
                scope: 'openid profile email phone',
                state: Math.random().toString(36).substring(2) // Random state for security
            }).toString();
            window.location.href = authorizeUrl.toString(); // Redirect to Authing
        }

        // Initiates Authing logout process
        window.logout = function() {
            const logoutUrl = new URL('/oidc/session/end', AUTHING_HOST);
             // Redirect back to the base origin after logout
            logoutUrl.search = new URLSearchParams({
                post_logout_redirect_uri: window.location.origin // Use base origin
            }).toString();
            // Clear local session data
            sessionStorage.removeItem('userInfo');
            sessionStorage.removeItem('accessToken');
            window.location.href = logoutUrl.toString(); // Redirect to Authing logout
        }

        // Updates the UI to show login/logout button and user info
        function renderLoginStatus(user) {
            const container = document.getElementById('login-status-container');
            const loginPrompt = document.getElementById('login-prompt');
            const mainContent = document.getElementById('main-content');
            if (!container || !i18next.isInitialized) return; // Ensure container and i18n exist

            if (user) { // User is logged in
                const displayName = user.nickname || user.name || user.preferred_username || user.email || i18next.t('nav.loggedIn');
                container.innerHTML = `<span class="text-sm font-medium text-gray-700 mr-2 hidden sm:inline">${displayName}</span><button onclick="logout()" class="px-3 py-1 text-xs font-medium rounded-full bg-red-500 text-white hover:bg-red-600">${i18next.t('nav.logout')}</button>`;
                if (loginPrompt) loginPrompt.classList.add('hidden');
                if (mainContent) mainContent.style.display = 'block'; // Show rating form
            } else { // User is not logged in
                container.innerHTML = `<button onclick="login()" class="px-3 py-1 text-xs font-medium rounded-full bg-green-500 text-white hover:bg-green-600">${i18next.t('nav.login')}</button>`;
                if (loginPrompt) loginPrompt.classList.remove('hidden');
                if (mainContent) mainContent.style.display = 'none'; // Hide rating form
            }
        }

        // Renders admin-specific navigation links if user has permissions
        function renderAdminLinks() {
            const adminLinksContainer = document.getElementById('admin-links-container');
            const configNavLink = document.getElementById('config-admin-link');
            const userManagementNavLink = document.getElementById('user-management-link');

            if (configNavLink) {
                configNavLink.classList.add('hidden');
            }
            if (userManagementNavLink) {
                userManagementNavLink.classList.add('hidden');
            }

            if (adminLinksContainer) {
                adminLinksContainer.innerHTML = '';
            }
            if (!currentAuthUser) return;

            const userRole = currentAuthUser.db_role; // Role from our database
            const isAdmin = userRole === 'admin' || userRole === 'super_admin';
            const isSuperAdmin = userRole === 'super_admin';

            // Show config link for admins and super admins
            if (isAdmin) {
                if (configNavLink) {
                    configNavLink.classList.remove('hidden');
                    if (i18next.isInitialized) {
                        configNavLink.textContent = i18next.t('nav.configAdmin');
                    }
                }
                if (adminLinksContainer) {
                    adminLinksContainer.innerHTML += `<a href="cigar_rating_config.html" class="flex items-center px-3 py-1.5 border text-xs font-medium rounded-full text-white bg-blue-600 hover:bg-blue-500 transition duration-150">${i18next.t('nav.configAdmin')}</a>`;
                }
            }
            // Show user management link only for super admins
            if (isSuperAdmin) {
                if (userManagementNavLink) {
                    userManagementNavLink.classList.remove('hidden');
                    if (i18next.isInitialized) {
                        userManagementNavLink.textContent = i18next.t('nav.userAdmin');
                    }
                }
                if (adminLinksContainer) {
                    adminLinksContainer.innerHTML += `<a href="role_management.html" class="flex items-center px-3 py-1.5 border text-xs font-medium rounded-full text-yellow-100 bg-purple-600 hover:bg-purple-500 ml-2 transition duration-150">${i18next.t('nav.userAdmin')}</a>`;
                }
            }
        }

        document.addEventListener('navbar:loaded', () => {
            renderLanguageSwitcher();
            renderLoginStatus(currentAuthUser);
        });

        // Handles the OIDC callback from Authing after successful login
        async function handleOidcCallback(code) {
            try {
                const redirectUri = window.location.origin; // Use base origin
                const apiUrl = new URL('/api/authing/callback', window.location.origin);
                // Send the code and redirect URI to our backend function
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ code: code, redirect_uri: redirectUri }) // Send base origin
                });
                if (!response.ok) { // Handle errors from our backend
                    let errorText = i18next.t('errors.authCallbackFailed', { status: response.status });
                    try { const err = await response.json(); errorText = err.error || errorText; } catch(e){}
                    throw new Error(errorText);
                }
                const fullUserProfile = await response.json(); // Contains Authing info + db_role
                // Store user info and token in session storage
                sessionStorage.setItem('userInfo', JSON.stringify(fullUserProfile));
                sessionStorage.setItem('accessToken', fullUserProfile.accessToken);
                return fullUserProfile;
            } catch (e) {
                console.error('Authing callback handling failed:', e);
                alert(i18next.t('errors.loginFailed', { message: e.message }));
                // Clear any partial session data on failure
                sessionStorage.removeItem('userInfo');
                sessionStorage.removeItem('accessToken');
                return null;
            } finally {
                // Clean up URL by removing code and state parameters from the address bar
                const cleanUrl = window.location.origin + window.location.pathname + window.location.search.replace(/&?code=[^&]*/, '').replace(/&?state=[^&]*/, '');
                window.history.replaceState({}, document.title, cleanUrl);
            }
        }

        // Validates the existing session token by calling our /api/me endpoint
        async function validateSessionAndGetUser() {
             const token = sessionStorage.getItem('accessToken');
            if (!token) return null; // No token, definitely not logged in
            try {
                // Call our '/api/me' endpoint which validates the token with Authing AND gets the DB role
                const apiUrl = new URL('/api/me', window.location.origin);
                const response = await fetch(apiUrl, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!response.ok) { // Token invalid or expired
                    sessionStorage.removeItem('userInfo');
                    sessionStorage.removeItem('accessToken');
                    return null;
                }
                const fullUserProfile = await response.json(); // Contains Authing info + db_role
                // Refresh userInfo in sessionStorage (in case role/nickname changed)
                sessionStorage.setItem('userInfo', JSON.stringify(fullUserProfile));
                return fullUserProfile;
            } catch (e) {
                console.error("Session validation network/fetch error:", e);
                return null; // Treat errors as logged out
            }
        }

        // Helper function to update the global user state and UI
        function setUser(user) {
            currentAuthUser = user;
            renderLoginStatus(currentAuthUser); // Update login/logout button and main content visibility
            // Update admin links (needs timeout for DOM update after login status change)
            setTimeout(() => { renderAdminLinks(); }, 0);
        }
        // --- End Authentication ---


        // --- Flavor Selection Logic ---
        // Renders the flavor selection buttons based on FLAVOR_KEYS
        function renderFlavorButtons() {
            const container = document.getElementById('flavor-buttons-container');
            if (!container || !i18next.isInitialized) return;
            container.innerHTML = ''; // Clear previous buttons
            FLAVOR_KEYS.forEach(flavorKey => {
                const isSelected = selectedFlavors.includes(flavorKey);
                const button = document.createElement('button');
                button.type = 'button';
                button.className = `flavor-btn ${isSelected ? 'selected' : ''}`;
                button.textContent = i18next.t(flavorKey); // Display translated flavor name
                button.dataset.flavorKey = flavorKey; // Store the key on the button for toggling
                button.onclick = () => toggleFlavorSelection(flavorKey, button);
                container.appendChild(button);
            });
        }

        // Toggles the selection state of a flavor button and updates the selectedFlavors array
        function toggleFlavorSelection(flavorKey, button) {
             const index = selectedFlavors.indexOf(flavorKey);
            if (index > -1) { // Flavor is currently selected
                selectedFlavors.splice(index, 1); // Remove key from array
                button.classList.remove('selected');
            } else { // Flavor is not selected
                selectedFlavors.push(flavorKey); // Add key to array
                button.classList.add('selected');
            }
            // console.log("Selected flavor keys:", selectedFlavors); // For debugging
        }
        // --- End Flavor Selection ---


        // --- Image Handling (Upload, Crop, Sort, Delete) ---
        const MAX_IMAGES = 5;       // Maximum number of images allowed
        const MAX_IMAGE_LONG_EDGE = 1280; // Target long edge size for uploads (roughly fits mobile screens)
        const MIN_CROP_BOX_SIZE = 180;    // Prevent crop box from collapsing into a point
        const OUTPUT_IMAGE_QUALITY = 0.85; // JPEG quality for uploads
        let filesToProcess = [];    // Array of files selected by user, waiting for cropping/upload
        let currentFileIndex = 0;   // Index of the file currently being processed

        // Renders image previews in the grid based on currentImageKeys array
        function renderImagePreviews() {
            const grid = document.getElementById('image-preview-grid');
            const uploadLabel = document.getElementById('image-upload-label');
            const uploadInput = document.getElementById('image-upload-input');
            grid.innerHTML = ''; // Clear existing previews

            currentImageKeys.forEach((key, index) => {
                const item = document.createElement('div');
                item.className = `preview-item ${index === 0 ? 'is-cover' : ''}`; // Mark first item as cover
                item.dataset.key = key; // Store the image key (UUID)
                const coverButtonText = index === 0 ? i18next.t('common.cover') : i18next.t('ratePage.setCover');
                item.innerHTML = `
                    <img src="/api/image/${key}" alt="${i18next.t('common.image')} ${index + 1}" loading="lazy" decoding="async" fetchpriority="low" width="400" height="533">
                    <button type="button" class="remove-btn" onclick="removeImage(event, ${index})" title="${i18next.t('common.delete')} ${i18next.t('common.image')}">&times;</button>
                    <button type="button" class="set-cover-btn" onclick="setCoverImage(event, ${index})" title="${coverButtonText}">
                        ${coverButtonText}
                    </button>
                `;
                grid.appendChild(item);
            });

            // Disable upload button if max images reached
            if (currentImageKeys.length >= MAX_IMAGES) {
                uploadLabel.classList.add('opacity-50', 'cursor-not-allowed', 'bg-gray-400');
                uploadLabel.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                uploadInput.disabled = true;
            } else {
                uploadLabel.classList.remove('opacity-50', 'cursor-not-allowed', 'bg-gray-400');
                uploadLabel.classList.add('bg-blue-600', 'hover:bg-blue-700');
                uploadInput.disabled = false;
            }
        }

        // Initializes SortableJS library for drag-and-drop image reordering
        function initializeSortable() {
            if (sortableInstance) {
                sortableInstance.destroy(); // Destroy previous instance if exists
            }
            sortableInstance = new Sortable(imageGrid, {
                animation: 150, // Animation speed
                ghostClass: 'sortable-ghost', // Class for placeholder
                dragClass: 'sortable-drag',   // Class for item being dragged
                onEnd: function (evt) { // Callback when dragging ends
                    // Rearrange the currentImageKeys array based on the new order
                    const movedItem = currentImageKeys.splice(evt.oldIndex, 1)[0];
                    currentImageKeys.splice(evt.newIndex, 0, movedItem);
                    renderImagePreviews(); // Re-render previews to update cover status/buttons
                },
            });
        }

        // Sets the image at the given index as the cover image (moves it to index 0)
        window.setCoverImage = function(event, index) {
            if (event) event.stopPropagation();
            if (index === 0 || index >= currentImageKeys.length) return; // Already cover or invalid index
            const keyToMove = currentImageKeys.splice(index, 1)[0]; // Remove item
            currentImageKeys.unshift(keyToMove); // Add to beginning
            renderImagePreviews(); // Re-render to update UI
        }

        // Removes the image at the specified index
        window.removeImage = function(event, indexToRemove) {
            if (event) event.stopPropagation();
            if (indexToRemove < 0 || indexToRemove >= currentImageKeys.length) return;
            // Note: We don't delete from R2 here, only remove from the list for this rating.
            // Actual deletion might happen if the rating itself is deleted later.
            currentImageKeys.splice(indexToRemove, 1);
            renderImagePreviews(); // Re-render previews
        }

        // Handles file selection from the input element
        window.handleFileSelect = function(event) {
            const status = document.getElementById('image-upload-status');
            status.textContent = ''; // Clear previous status
            const selectedFiles = Array.from(event.target.files);
            if (selectedFiles.length === 0) return;

            if (!currentAuthUser) { // Check login status
                alert(i18next.t('ratePage.loginToUpload'));
                return;
            }

            // Filter selected files based on limits, size, and type
            const allowedFiles = [];
            for (const file of selectedFiles) {
                if (currentImageKeys.length + allowedFiles.length >= MAX_IMAGES) {
                    alert(i18next.t('ratePage.maxImages', { max: MAX_IMAGES }));
                    break; // Stop processing if max limit reached
                }
                if (file.size > 5 * 1024 * 1024) { // Check size (5MB)
                    alert(i18next.t('ratePage.imageTooLarge', { name: file.name }));
                    continue; // Skip this file
                }
                if (!['image/jpeg', 'image/png', 'image/webp'].includes(file.type)) { // Check type
                    alert(i18next.t('ratePage.imageTypeNotSupported', { name: file.name }));
                    continue; // Skip this file
                }
                allowedFiles.push(file);
            }

            // If valid files were selected, start the cropping process
            if (allowedFiles.length > 0) {
                filesToProcess = allowedFiles;
                currentFileIndex = 0;
                showCropperForNextFile();
            }

            event.target.value = null; // Reset file input to allow selecting the same file again
        }

        // Shows the cropper modal for the next file in the filesToProcess array
        function showCropperForNextFile() {
            if (currentFileIndex >= filesToProcess.length) { // All files processed
                filesToProcess = []; // Clear the processing queue
                cancelCrop(); // Close the modal
                return;
            }

            const file = filesToProcess[currentFileIndex];
            const reader = new FileReader();
            reader.onload = (e) => { // When file is read
                cropperModal.classList.remove('hidden'); // Show modal
                cropperImage.src = e.target.result; // Set image source for cropper

                // Initialize or reinitialize Cropper.js
                if (cropper) cropper.destroy();
                cropper = new Cropper(cropperImage, {
                    viewMode: 1, // Restrict crop box to canvas
                    dragMode: 'move', // Prevent accidental tiny crop boxes
                    autoCropArea: 0.9, // Initial crop area size
                    background: false, // Hide grid background
                    movable: true,
                    cropBoxMovable: true,
                    cropBoxResizable: true,
                    minCropBoxWidth: MIN_CROP_BOX_SIZE,
                    minCropBoxHeight: MIN_CROP_BOX_SIZE,
                    toggleDragModeOnDblclick: false,
                    responsive: true,
                });
                // Update status message
                cropperStatus.textContent = i18next.t('ratePage.processingImage', { current: currentFileIndex + 1, total: filesToProcess.length });
            };
            reader.readAsDataURL(file); // Read the file as Data URL
        }

        // Confirms the crop, uploads the cropped image, and proceeds to the next file
        window.confirmCropAndUpload = async function() {
            if (!cropper || !filesToProcess[currentFileIndex]) return; // Safety check

            const token = sessionStorage.getItem('accessToken');
            if (!token) { // Check login token
                alert(i18next.t('common.sessionExpired'));
                cancelCrop(); // Close modal on error
                return;
            }

            cropperStatus.textContent = i18next.t('ratePage.croppingAndUploading', { current: currentFileIndex + 1 });
            const originalFileName = filesToProcess[currentFileIndex].name;

            // Get cropped canvas data and downscale/compress for mobile-friendly storage
            const baseCanvas = cropper.getCroppedCanvas({
                fillColor: '#ffffff',
                imageSmoothingEnabled: true,
                imageSmoothingQuality: 'high',
            });

            if (!baseCanvas) {
                cropperStatus.textContent = i18next.t('ratePage.cropFailed');
                return;
            }

            let outputCanvas = baseCanvas;
            const originalWidth = baseCanvas.width;
            const originalHeight = baseCanvas.height;
            const longestEdge = Math.max(originalWidth, originalHeight);

            if (longestEdge > MAX_IMAGE_LONG_EDGE) {
                const scale = MAX_IMAGE_LONG_EDGE / longestEdge;
                const targetWidth = Math.round(originalWidth * scale);
                const targetHeight = Math.round(originalHeight * scale);
                const resizedCanvas = document.createElement('canvas');
                resizedCanvas.width = targetWidth;
                resizedCanvas.height = targetHeight;
                const ctx = resizedCanvas.getContext('2d');
                if (ctx) {
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    ctx.drawImage(baseCanvas, 0, 0, targetWidth, targetHeight);
                    outputCanvas = resizedCanvas;
                }
            }

            outputCanvas.toBlob(async (blob) => {
                if (!blob) { // Handle blob creation failure
                    cropperStatus.textContent = i18next.t('ratePage.cropFailed');
                    return;
                }

                try {
                    // Create FormData to send the blob to the API
                    const formData = new FormData();
                    // Append blob with original filename (API generates UUID anyway)
                    formData.append('image', blob, originalFileName);

                    // Call the upload API endpoint
                    const response = await fetch('/api/upload-image', {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${token}` }, // Add auth token
                        body: formData
                    });
                    const result = await response.json();
                    if (!response.ok) throw new Error(result.error || 'Upload failed'); // Handle API errors

                    // Upload successful, add the returned key to our list
                    currentImageKeys.push(result.imageKey);
                    renderImagePreviews(); // Update the UI

                    // Process the next file
                    currentFileIndex++;
                    showCropperForNextFile();

                } catch (e) {
                    console.error("Image upload failed:", e);
                    cropperStatus.textContent = i18next.t('ratePage.uploadFailed', { msg: e.message });
                    // Don't proceed to next file on error, let user retry or cancel
                }
            }, 'image/jpeg', OUTPUT_IMAGE_QUALITY); // Output as JPEG with tuned quality
        }

        // Cancels the cropping process and closes the modal
        window.cancelCrop = function() {
            cropperModal.classList.add('hidden'); // Hide modal
            if (cropper) {
                cropper.destroy(); // Destroy cropper instance
                cropper = null;
            }
            cropperImage.src = ''; // Clear image source
            cropperStatus.textContent = ''; // Clear status message
        }
        // --- End Image Handling ---


        // --- Core Rating Logic ---
        // Loads the rating configuration from the API
        async function loadConfig() {
            document.getElementById('config-load-status').textContent = i18next.t('ratePage.configSyncing');
            try {
                const apiUrl = new URL('/api/config/latest', window.location.origin); // Fetch 'latest' config
                const response = await fetch(apiUrl);
                if (!response.ok) throw new Error(`Server error: ${response.statusText}`);
                ratingConfig = await response.json(); // Store config globally
                if (!ratingConfig || !ratingConfig.ratingCriteria) throw new Error("Loaded config is invalid.");

                // Pre-calculate total criteria count and max score for progress display
                calculateWeights(ratingConfig);

                // Initialize/reset user selections and render the rating form
                userRatings = {};
                renderRatingView();
                document.getElementById('config-load-status').textContent = i18next.t('ratePage.configSynced');
            } catch (error) {
                console.error("Failed to load rating config:", error);
                document.getElementById('config-load-status').textContent = i18next.t('ratePage.configFailed');
                // Display error and potentially prevent rating
                alert(`Failed to load core app configuration. Please refresh.\nDetails: ${error.message}`);
                // Optionally disable the form here
            }
        }

        // Generates a unique ID string for a rating criterion based on its category and name keys
        function getRatingId(categoryKey, criterionKey) {
            // Use keys directly to ensure consistency regardless of language
            return `${categoryKey}-${criterionKey}`;
        }

        // Pre-calculates total criteria count and theoretical maximum score
        function calculateWeights(config) {
            let totalCriteriaCount = 0;
            let totalWeightMax = 0;
            (config?.ratingCriteria || []).forEach(category => {
                (category?.criteriaList || []).forEach(criterion => {
                    totalCriteriaCount++;
                    totalWeightMax += criterion.weight || 0;
                });
            });
            config.totalCriteriaCount = totalCriteriaCount; // Store on config object
            config.totalWeightMax = totalWeightMax;         // Store on config object
        }

        // Calculates the current total score based on user selections
        function calculateFinalScore() {
            let totalScore = 0;
            if (!ratingConfig || !ratingConfig.ratingCriteria) return 0;

            // Iterate through the config structure
            ratingConfig.ratingCriteria.forEach(category => {
                category.criteriaList?.forEach(criterion => {
                    // Generate the ID using keys
                    const id = getRatingId(category.categoryKey, criterion.nameKey);
                    const selectedOptionIndex = userRatings[id]; // Get user's choice for this criterion

                    // If user selected an option and the option exists
                    if (selectedOptionIndex !== undefined && criterion.options?.[selectedOptionIndex]) {
                        const option = criterion.options[selectedOptionIndex];
                        const weight = criterion.weight || 0;
                        const scorePct = option.scorePct || 0;
                        totalScore += weight * scorePct; // Add weighted score
                    }
                });
            });
            return totalScore;
        }

        // Updates user's selection for a criterion and recalculates the score
        window.updateRatingSelection = function(categoryKey, criterionKey, optionIndex) {
            const id = getRatingId(categoryKey, criterionKey); // Generate ID from keys
            if (userRatings[id] === optionIndex) {
                // If clicking the same option again, deselect it (optional behavior)
                 // delete userRatings[id];
                 // console.log(`Deselected: ${id}`);
                 return; // Keep selected if clicked again - current behavior
            } else {
                userRatings[id] = optionIndex; // Store the selected option index
                // console.log(`Selected: ${id} = ${optionIndex}`);
            }
            renderRatingView(); // Re-render the form to update score and button states
        };

        // Renders the entire rating form based on the loaded config and user selections
        function renderRatingView() {
            // Ensure config is loaded and i18n is ready
            if (!ratingConfig || !ratingConfig.ratingCriteria || !i18next.isInitialized) {
                const formContainer = document.getElementById('rating-form-container');
                formContainer.innerHTML = `<div class="text-center p-6 bg-white rounded-lg shadow"><p>${i18next.t('ratePage.configFailed')}</p></div>`;
                return;
            };

            // Update header display (score, progress)
            const totalScore = calculateFinalScore();
            // Use i18next.t() for app title and description if they are keys
            document.getElementById('app-title-display').textContent = i18next.t(ratingConfig.appTitle || "Rating App");
            document.getElementById('app-description-display').textContent = i18next.t(ratingConfig.description || "Loading description...");
            document.getElementById('total-weight-max-display').textContent = ratingConfig.totalWeightMax ?? 0;
            document.getElementById('current-score-display').textContent = formatIntegerScore(totalScore);

            // Update progress bar
            const ratedCount = Object.keys(userRatings).length;
            const totalCount = ratingConfig.totalCriteriaCount || 1; // Avoid division by zero
            document.getElementById('progress-bar').style.width = `${(ratedCount / totalCount) * 100}%`;
            document.getElementById('progress-text').textContent = `${ratedCount} / ${totalCount}`;

            // Get the container for the rating criteria
            const formContainer = document.getElementById('rating-form-container');
            // Generate HTML for each category
            formContainer.innerHTML = ratingConfig.ratingCriteria.map((category) => `
                <div class="bg-white p-4 sm:p-6 rounded-xl shadow-lg mb-6 sm:mb-8 border-l-4 border-indigo-500">
                    <h3 class="text-lg sm:text-xl font-bold text-indigo-700 mb-2">${i18next.t(category.categoryKey)}</h3>
                    <p class="text-gray-500 text-sm mb-4">${i18next.t(category.detailKey) || ''}</p>
                    <div class="space-y-5 sm:space-y-6">
                        ${(category.criteriaList || []).map((criterion) => renderRatingCriterion(category.categoryKey, criterion)).join('')}
                    </div>
                </div>`).join('');
        }

        // Renders a single rating criterion section (name, options, score)
        function renderRatingCriterion(categoryKey, criterion) {
            const criterionKey = criterion.nameKey;
            const id = getRatingId(categoryKey, criterionKey); // ID based on keys
            const selectedOptionIndex = userRatings[id]; // User's current selection
            const currentWeight = criterion.weight || 0;
            let currentScore = 0; // Score for this specific criterion

            // Calculate score for this criterion if an option is selected
            if (selectedOptionIndex !== undefined && criterion.options?.[selectedOptionIndex]) {
                currentScore = currentWeight * (criterion.options[selectedOptionIndex].scorePct || 0);
            }
            // Check if current user is super admin for displaying weights/scores
            const isSuperAdmin = currentAuthUser?.db_role === 'super_admin';

            // Generate HTML for the criterion
            return `
            <div class="bg-gray-50 p-3 sm:p-4 rounded-lg border">
                <div class="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between mb-3">
                    <h4 class="text-base sm:text-lg font-semibold text-gray-800">
                        ${i18next.t(criterionKey)} ${isSuperAdmin ? `(${currentWeight} ${i18next.t('common.points')})` : ''}
                    </h4>
                    <span class="text-lg sm:text-xl font-extrabold text-green-600">${formatIntegerScore(currentScore)}</span>
                </div>
                <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-2 sm:gap-3">
                ${(criterion.options || []).map((option, optIndex) => {
                    const isSelected = selectedOptionIndex === optIndex; // Check if this option is selected
                    const scoreValue = formatIntegerScore(currentWeight * (option.scorePct || 0)); // Score for this option
                    return `<button type="button" onclick="updateRatingSelection('${categoryKey}', '${criterionKey}', ${optIndex})"
                        class="p-2 sm:p-3 text-xs sm:text-sm text-center rounded-lg border transition ${isSelected ? 'bg-indigo-600 text-white shadow-md' : 'bg-white hover:bg-indigo-50'}">
                        ${i18next.t(option.descriptionKey)}
                        <span class="block text-[0.65rem] sm:text-xs ${isSelected ? 'text-indigo-200' : 'text-gray-500'}">(${i18next.t('common.score')} ${scoreValue} ${i18next.t('common.points')})</span>
                    </button>`;
                }).join('')}
                </div>
            </div>`;
        }
        // --- End Core Rating Logic ---


        // --- Actions (Reset, Show Results / Save Changes) ---
        // Resets the entire rating form to its initial state
        window.resetRatings = function() {
            if (confirm(i18next.t('ratePage.confirmReset'))) { // Ask for confirmation
                // Clear user selections and input fields
                userRatings = {};
                titleInput.value = '';
                document.getElementById('cigar-name').value = '';
                document.getElementById('cigar-size').value = '';
                document.getElementById('cigar-origin').value = '';
                reviewTextarea.value = '';
                currentImageKeys = [];
                selectedFlavors = [];

                // Re-render components to reflect reset state
                renderFlavorButtons();
                renderImagePreviews();
                renderRatingView(); // This recalculates score and updates progress
                updateCharCounts(); // Reset character counts

                // If in edit mode, exit edit mode
                if (isEditMode) {
                    isEditMode = false;
                    editRatingId = null;
                    mainActionButton.textContent = i18next.t('ratePage.viewReport'); // Change button text back
                    mainActionButton.classList.remove('bg-blue-600', 'hover:bg-blue-700'); // Revert button style
                    mainActionButton.classList.add('bg-green-600', 'hover:bg-green-700');
                    // Remove edit parameter from URL
                    window.history.replaceState({}, document.title, window.location.pathname);
                }
            }
        }

        // Gathers all data, navigates to results page (new rating) or saves changes (edit mode)
        window.showResults = async function() {
            // ... (Validation checks remain the same) ...
            const token = sessionStorage.getItem('accessToken');
            if (!isEditMode && (!currentAuthUser || !token)) {
                return alert(i18next.t('ratePage.loginToSubmit'));
            }
            if (!ratingConfig || Object.keys(userRatings).length === 0) {
                return alert(i18next.t('ratePage.selectOneOption'));
            }
             const title = titleInput.value.trim();
            if (!title) {
                return alert(i18next.t('ratePage.titleRequired'));
            }
            if (currentImageKeys.length === 0) {
                return alert(i18next.t('ratePage.imageRequired'));
            }
            const cigarNameValue = document.getElementById('cigar-name').value.trim();
            if (!cigarNameValue) {
                return alert(i18next.t('ratePage.nameRequired'));
            }


            // ... (Data gathering remains the same) ...
            const cigarInfo = {
                name: cigarNameValue,
                size: document.getElementById('cigar-size').value || i18next.t('common.unknown'), // Use translated 'unknown'
                origin: document.getElementById('cigar-origin').value || i18next.t('common.unknown') // Use translated 'unknown'
            };
            const reviewRaw = reviewTextarea.value ? reviewTextarea.value.trim() : '';
            const cigarReview = reviewRaw || '';
            const sourceLanguage = (i18next.language || 'zh').split('-')[0];
            const finalScore = calculateFinalScore();
            const maxScore = ratingConfig.totalWeightMax || 1; // Avoid division by zero
            const normalizedScore = maxScore > 0 ? (finalScore / maxScore) * 100 : 0; // Normalize score to 0-100
            const foundGrade = GRADING_SCALE.find(g => normalizedScore >= g.min_score) || GRADING_SCALE[GRADING_SCALE.length - 1]; // Find matching grade or use lowest
            const finalGrade = {
                grade: foundGrade.grade,
                nameKey: foundGrade.nameKey, // Pass the i18n key for the grade name
                color: foundGrade.color      // Pass color associated with the grade
            };

            // --- ADDED LOG ---
            console.log("[rate.html showResults] Calculated finalGrade:", JSON.stringify(finalGrade));

            // Prepare the data object
            const resultsData = {
                title: title,
                config: ratingConfig,           // Include the config used for rating
                ratings: userRatings,           // User's selections { "catKey-critKey": index }
                calculatedScore: finalScore,    // Raw calculated score
                cigarInfo: cigarInfo,
                cigarReview: cigarReview,
                imageUrls: currentImageKeys,    // Array of image keys
                normalizedScore: normalizedScore, // Score normalized to 0-100
                finalGrade: finalGrade,         // Grade object { grade, nameKey, color }
                selectedFlavors: selectedFlavors, // Array of selected flavor keys
                isDraft: !isEditMode,           // Mark as draft if it's a new rating
                userNickname: currentAuthUser?.nickname || currentAuthUser?.name || currentAuthUser?.preferred_username || currentAuthUser?.email,
                userEmail: currentAuthUser?.email,
                sourceLanguage: sourceLanguage
            };

            // --- ADDED LOG ---
            console.log("[rate.html showResults] resultsData object before saving:", JSON.stringify(resultsData).substring(0, 500) + '...'); // Log first 500 chars

            // Handle Edit Mode: Save changes via PUT request
            if (isEditMode && editRatingId) {
                mainActionButton.textContent = i18next.t('common.saving'); // Update button text
                mainActionButton.disabled = true;
                try {
                    if (!token) throw new Error(i18next.t('common.sessionExpiredWrite')); // Re-check token
                    resultsData.ratingId = editRatingId; // Add the ID for the PUT request
                    const apiUrl = new URL(`/api/ratings`, window.location.origin);
                    const response = await fetch(apiUrl, {
                        method: 'PUT', // Use PUT for updates
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
                        body: JSON.stringify(resultsData)
                    });
                    if (!response.ok) { const err = await response.json(); throw new Error(err.error || 'Update failed'); } // Handle API error
                    alert(i18next.t('common.saveSuccess')); // Show success message
                    window.location.href = 'history.html'; // Redirect to history page after saving
                } catch (e) {
                    alert(i18next.t('common.saveFailed', { msg: e.message })); // Show error message
                    // Reset button state on failure
                    mainActionButton.textContent = i18next.t('ratePage.saveChanges');
                    mainActionButton.disabled = false;
                }
            }
            // Handle New Rating Mode: Store data in session storage and navigate to results page
            else {
                try {
                    // Store the complete rating data for the results page to display
                    sessionStorage.setItem('cigarRatingResults', JSON.stringify(resultsData));
                    window.location.href = 'results.html'; // Navigate to results page
                } catch (e) {
                    console.error("Error storing results in sessionStorage:", e);
                    alert(i18next.t('common.sessionStoreFailed')); // Show error if storage fails
                }
            }
        };
        // --- End Actions ---

        // --- Utility Functions ---
        // Updates character counts for title and review fields
        function updateCharCounts() {
            if(titleInput && titleCharCount) titleCharCount.textContent = `${titleInput.value.length} / ${TITLE_MAX_LENGTH}`;
            if(reviewTextarea && reviewCharCount) reviewCharCount.textContent = `${reviewTextarea.value.length} / 1500`;
        }

        // Loads data for editing if 'edit' parameter is present in URL
        async function loadRatingForEdit(ratingId) {
             const status = document.getElementById('config-load-status'); // Use config status area
             status.textContent = i18next.t('ratePage.loadingEdit', { id: ratingId.substring(0, 8) + '...' });
             mainActionButton.textContent = i18next.t('ratePage.saveChanges'); // Change button text
             mainActionButton.classList.remove('bg-green-600', 'hover:bg-green-700'); // Change button style
             mainActionButton.classList.add('bg-blue-600', 'hover:bg-blue-700');
             isEditMode = true;
             editRatingId = ratingId;
             currentImageKeys = []; // Initialize image keys

            try {
                const token = sessionStorage.getItem('accessToken');
                if (!token) throw new Error(i18next.t('common.sessionExpiredRead', { status: 'none'}));

                const apiUrl = new URL('/api/ratings', window.location.origin);
                apiUrl.searchParams.set('id', ratingId);
                if (shouldUseCompactApiPayload()) {
                    apiUrl.searchParams.set('view', 'mobile');
                }
                const currentLang = (i18next.language || 'zh').split('-')[0];
                apiUrl.searchParams.set('lang', currentLang);
                const response = await fetch(apiUrl, { headers: { 'Authorization': `Bearer ${token}` } });
                if (!response.ok) { throw new Error(i18next.t('ratePage.editLoadFailed', { msg: `Status ${response.status}` })); }

                const data = await response.json();
                const ratingPayload = data.mobileData || data.fullData || {};

                // Populate form fields
                titleInput.value = data.title || ratingPayload.title || '';
                const infoSource = data.cigarInfo || ratingPayload.cigarInfo || {};
                document.getElementById('cigar-name').value = infoSource.name || '';
                document.getElementById('cigar-size').value = infoSource.size || '';
                document.getElementById('cigar-origin').value = infoSource.origin || '';
                const reviewSource = data.cigarReview || ratingPayload.cigarReview;
                reviewTextarea.value = (reviewSource && reviewSource !== i18next.t('common.noReview')) ? reviewSource : '';

                // FIX: Ensure imageUrls from data is used, default to empty array
                const imageSource = Array.isArray(data.imageUrl) ? data.imageUrl : (Array.isArray(ratingPayload.imageUrls) ? ratingPayload.imageUrls : []);
                currentImageKeys = imageSource;

                selectedFlavors = Array.isArray(data.selectedFlavors) ? data.selectedFlavors : (Array.isArray(ratingPayload.selectedFlavors) ? ratingPayload.selectedFlavors : []); // Load flavor keys

                // Load user selections (ratings) - critical: use the data from fullData
                // Ensure fullData and ratings exist
                if (ratingPayload && ratingPayload.ratings) {
                     userRatings = ratingPayload.ratings; // Use the stored ratings object directly
                } else {
                     console.warn("Editing rating, but fullData.ratings is missing. Score might be inaccurate.");
                     userRatings = {}; // Fallback to empty if missing
                }

                // Re-render UI components AFTER data is loaded
                renderImagePreviews(); // Render images using updated currentImageKeys
                renderFlavorButtons();
                renderRatingView(); // Important: call after userRatings is populated
                updateCharCounts();

                status.textContent = i18next.t('ratePage.editLoaded', { id: ratingId.substring(0, 8) + '...' });
            } catch (error) {
                console.error("Failed to load rating for editing:", error);
                status.textContent = i18next.t('ratePage.editLoadFailed', { msg: error.message });
                alert(i18next.t('ratePage.editLoadFailed', { msg: error.message }) + "\n" + i18next.t('common.backToHomePrompt')); // Using generic prompt key
                window.location.href = 'history.html'; // Redirect back if loading fails
            }
        }
        // --- End Utility Functions ---


        // --- Initialization ---
        // Runs when the page is fully loaded
        window.addEventListener('load', async function() {
            try {
                 // 1. Initialize i18next for translations
                 await initI18n();

                 // 2. Handle Authentication (check URL for code, validate session)
                 const urlParams = new URLSearchParams(window.location.search);
                 const code = urlParams.get('code');        // Check for OIDC code from redirect
                 const editIdParam = urlParams.get('edit'); // Check for edit mode parameter

                 let user = code ? await handleOidcCallback(code) : await validateSessionAndGetUser();
                 setUser(user); // Update global user state and UI

                 // 3. Setup UI Elements (language switcher, char counts, sortable images)
                 renderLanguageSwitcher();
                 titleInput?.addEventListener('input', updateCharCounts); // Add listener if element exists
                 reviewTextarea?.addEventListener('input', updateCharCounts); // Add listener if element exists
                 updateCharCounts(); // Initial count update
                 initializeSortable(); // Setup drag-and-drop for images

                 // 4. Load Core Rating Configuration (essential for rating)
                 await loadConfig(); // Fetches config from /api/config/latest

                 // 5. Load Data for Editing (if applicable)
                 // Must happen *after* config is loaded and user is validated
                 if (editIdParam && currentAuthUser) {
                      await loadRatingForEdit(editIdParam);
                 } else {
                      // Ensure flavor buttons are rendered even if not editing
                      renderFlavorButtons();
                 }

            } catch (error) {
                 console.error("Initialization failed:", error);
                 // Display a general error message if something critical fails during init
                 const status = document.getElementById('config-load-status');
                 if (status) {
                      status.textContent = i18next.isInitialized ? i18next.t('errors.initFailed', { msg: error.message }) : `Initialization Error: ${error.message}`;
                      status.style.color = 'red';
                 }
                 // Optionally hide the main content if init fails severely
                 const mainContent = document.getElementById('main-content');
                 if(mainContent) mainContent.style.display = 'none';
            }
        });
        // --- End Initialization ---

    </script>
</body>
</html>

