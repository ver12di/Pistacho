<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="查看 Pistacho 雪茄品鉴报告，回顾完整的评分细节、口感总结与分享卡片。">
    <meta name="keywords" content="Pistacho, 雪茄报告, 品鉴结果, 雪茄评分, 分享卡片">
    <meta name="robots" content="index, follow">
    <meta property="og:title" content="雪茄品鉴报告 - Pistacho">
    <meta property="og:description" content="在 Pistacho 浏览详细的雪茄点评结果，生成二维码分享并导出高分卡片。">
    <meta property="og:type" content="website">
    <meta property="og:image" content="Certifiedstamp.png">
    <meta property="og:locale" content="zh_CN">
    <meta property="og:url" content="https://www.pista-cho.com/results.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="雪茄品鉴报告 - Pistacho">
    <meta name="twitter:description" content="查看 Pistacho 雪茄品鉴报告，回顾完整的评分细节、口感总结与分享卡片。">
    <meta name="twitter:image" content="Certifiedstamp.png">
    <title>雪茄品鉴 - 点评报告</title>
    <link rel="icon" type="image/png" href="Certifiedstamp.png">

    <link rel="preconnect" href="https://cdn.tailwindcss.com" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="preconnect" href="https://unpkg.com" crossorigin>
    <script src="https://cdn.tailwindcss.com" defer></script>

    <script src="https://unpkg.com/i18next/i18next.min.js" defer></script>
    <script src="https://unpkg.com/i18next-http-backend/i18nextHttpBackend.min.js" defer></script>
    <script src="https://unpkg.com/i18next-browser-languagedetector/i18nextBrowserLanguageDetector.min.js" defer></script>
    <script type="module" src="scripts/navbar.js"></script>

    <script>
        window.tailwind = window.tailwind || {};
        window.tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'Noto Sans SC', 'system-ui', 'sans-serif'],
                    },
                }
            }
        };
    </script>
    <style>
        /* Language switcher buttons */
        .lang-button {
            padding: 2px 8px;
            margin: 0 2px;
            border: 1px solid transparent;
            border-radius: 9999px;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 600;
            background-color: #f3f4f6;
            color: #374151;
            transition: all 0.2s ease;
        }
        .lang-button:hover {
            background-color: #e5e7eb;
        }
        .lang-button.active {
            background-color: #e0e7ff;
            border-color: #a5b4fc;
            color: #3730a3;
            cursor: default;
        }

        /* Tooltip style */
        .tooltip { position: relative; display: inline-block; }
        .tooltip .tooltiptext { visibility: hidden; width: 60px; background-color: #555; color: #fff; text-align: center; border-radius: 6px; padding: 5px 0; position: absolute; z-index: 1; bottom: 125%; left: 50%; margin-left: -30px; opacity: 0; transition: opacity 0.3s; font-size: 10px; }
        .tooltip .tooltiptext::after { content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: #555 transparent transparent transparent; }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }
        /* Swiper styles */
        .swiper-container.main-swiper { width: 100%; position: relative; }
        .swiper-slide { height: auto; display: flex; flex-direction: column; align-items: center; /* Center content */ justify-content: center; /* Center content */ }
        /* --- Ensure slides adapt height --- */
        .swiper-wrapper { align-items: flex-start; /* Prevent vertical stretching */ }
        .swiper-slide img { display: block; width: 100%; height: auto; object-fit: contain; max-height: 80vh; }
        .swiper-slide.share-image-slide img { max-height: none; object-fit: contain; }
        .swiper-button-next, .swiper-button-prev { color: #fff; background-color: rgba(0,0,0,0.3); padding: 10px; border-radius: 50%; width: 40px; height: 40px; } .swiper-button-next::after, .swiper-button-prev::after { font-size: 1.2rem; }
        /* --- MODIFIED: Adjust Swiper Pagination Position --- */
        .swiper-pagination { display: none !important; }
        /* --- End Modified Swiper Pagination --- */
        .thumbnail-swiper .swiper-slide { width: 60px !important; height: 80px; opacity: 0.6; cursor: pointer; border: 2px solid transparent; transition: opacity 0.3s, border-color 0.3s; }
        .thumbnail-swiper .swiper-slide img { object-fit: cover; width: 100%; height: 100%;}
        .thumbnail-swiper .swiper-slide-thumb-active { opacity: 1; border-color: #4f46e5; } .thumbnail-swiper { margin-top: 0.5rem; padding: 5px 0; }
        /* Content container width */
        #narrative-summary-container, #cigar-review-container, #selected-flavors-container { max-width: 100%; }
        /* Flavor tag style */
        .flavor-tag { display: inline-block; background-color: #e5e7eb; color: #374151; font-size: 0.75rem; font-weight: 600; margin-right: 0.5rem; margin-bottom: 0.5rem; padding: 0.125rem 0.625rem; border-radius: 9999px; }

        /* --- MODIFIED: Share Card Styles --- */
        #share-card-container {
            position: absolute; left: -9999px; top: 0; width: 350px; /* Fixed width */
            background-color: white; border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            overflow: hidden; border: 1px solid #e5e7eb; visibility: hidden; z-index: -1;
        }
        #share-card-image-wrapper {
            background-color: #e5e7eb; display: flex; align-items: center; justify-content: center;
            aspect-ratio: 1179 / 1572; /* Keep aspect ratio */
            position: relative;
        }
        #share-card-image-wrapper.no-image #share-card-pagination { display: none; }
        #share-card-image { width: 100%; height: 100%; object-fit: cover; }
        #share-card-pagination {
            position: absolute;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
        }
        #share-card-pagination span {
            width: 6px;
            height: 6px;
            border-radius: 9999px;
            background-color: rgba(156, 163, 175, 0.8); /* Gray-400 with slight transparency */
        }
        #share-card-content {
            padding: 8px; /* Adjust padding if needed */
            display: flex; /* Use flexbox for layout */
            justify-content: space-between; /* Space between left (score/text) and right (QR) */
            align-items: flex-end; /* Align items to the bottom */
            min-height: 75px; /* Adjust min-height as needed, but try to keep it compact */
        }
        #share-card-left {
            display: flex;
            flex-direction: column; /* Stack score, grade, watermark */
            justify-content: flex-end; /* Align items to bottom */
            flex-grow: 1; /* Allow left side to take available space */
            margin-right: 8px; /* Add space between left and QR */
        }
        #share-card-score {
            font-size: 2.5rem; /* Slightly smaller score */ font-weight: 900; line-height: 0.9; /* Tighter line height */
            margin-bottom: 6px; /* Increased space below score */
        }
        #share-card-grade-badge {
             /* Grade badge styles */
             display: inline-block; /* Allow it to sit below score */
             padding: 1px 6px; /* Adjust padding */
             border-radius: 9999px;
             font-size: 0.9rem; /* Larger grade label */ font-weight: 600;
             margin-bottom: 3px; /* --- MODIFIED: Adjusted space below grade --- */
             /* Color applied dynamically */
        }
        #share-card-watermark {
            font-size: 0.55rem; color: #9ca3af; line-height: 1.1; margin: 0; /* Remove default margin */
            /* Removed width constraint, let flexbox handle it */
        }
        #share-card-qrcode {
            width: 110px; /* Increased width for better scanability */ height: 110px; /* Increased height */
            flex-shrink: 0; /* Prevent QR code from shrinking */
            background-color: white; padding: 2px; /* Small padding around QR */
            border: 1px solid #eee; box-shadow: 0 0 2px rgba(0,0,0,0.1);
            display: flex; /* Center the img tag if needed */
            align-items: center;
            justify-content: center;
        }
        #share-card-qrcode img {
            display: block; width: 100%; height: 100%; object-fit: contain; /* Ensure QR fits */
        }
        /* --- End Modified Share Card Styles --- */
    </style>
</head>
<body class="bg-gray-100 font-sans antialiased text-gray-800">
    <div class="px-4 sm:px-6 lg:px-8 pt-4">
        <div class="mx-auto max-w-7xl">
            <div data-include-nav data-active="history" data-language="flags"></div>
        </div>
    </div>
    <div class="max-w-6xl mx-auto p-4 md:p-8 relative">
        <!-- Error Container -->
        <div id="error-container" class="hidden bg-red-100 p-6 rounded-lg shadow-lg text-red-700 font-medium"></div>
        <!-- Loading Indicator -->
        <div id="loading-indicator" class="hidden text-center py-10 text-gray-500" data-i18n="common.loadingDetails">正在加载评分详情...</div>

        <!-- Main Content (hidden initially) -->
        <div id="main-content" class="opacity-0">
            <!-- Main Layout: Image Gallery + Details -->
            <div class="flex flex-col md:flex-row gap-6 md:gap-8 mb-8">
                <!-- Image Gallery -->
                <div class="w-full md:w-2/5 flex-shrink-0">
                     <div id="image-gallery-container" class="bg-white rounded-lg shadow-md overflow-hidden">
                         <!-- Main Swiper -->
                         <div class="swiper-container main-swiper bg-gray-200 relative">
                              <div class="swiper-wrapper" id="main-swiper-wrapper">
                                  <div class="swiper-slide flex items-center justify-center text-gray-400 aspect-[1179/1572]" data-i18n="common.loading">加载中...</div>
                              </div>
                              <div class="swiper-pagination"></div>
                              <div class="swiper-button-next"></div>
                              <div class="swiper-button-prev"></div>
                         </div>
                         <!-- Thumbnail Swiper (hidden if only one image or share image present) -->
                         <div class="swiper-container thumbnail-swiper hidden"> <div class="swiper-wrapper" id="thumbnail-swiper-wrapper"> </div> </div>
                     </div>
                </div>
                 <!-- Rating Details -->
                 <div class="w-full md:flex-grow bg-white rounded-lg shadow-md p-6">
                     <!-- Author -->
                     <p class="text-sm text-gray-500 mb-1">
                         <span data-i18n="resultsPage.by">点评来自:</span>
                         <span id="user-nickname" class="font-medium text-gray-700"></span>
                     </p>
                     <!-- Rating Title -->
                     <h1 id="rating-title" class="text-3xl font-bold mb-3"></h1>
                     <!-- Cigar Info -->
                     <h2 id="cigar-name" class="text-xl font-semibold mb-1"></h2>
                     <div class="mb-4 text-sm text-gray-600 flex space-x-4">
                         <span><span data-i18n="resultsPage.size">尺寸</span>: <strong id="cigar-size"></strong></span>
                         <span><span data-i18n="resultsPage.origin">产地</span>: <strong id="cigar-origin"></strong></span>
                     </div>
                     <!-- Written Review -->
                     <div id="cigar-review-container" class="prose prose-sm max-w-none text-gray-700 border-t pt-4">
                         <!-- Review content inserted by JS -->
                     </div>
                     <!-- Selected Flavors -->
                     <div id="selected-flavors-container" class="hidden pt-2">
                         <h4 class="text-sm font-semibold text-gray-600 mb-2" data-i18n="resultsPage.flavors">主要风味:</h4>
                         <div id="flavors-display" class="flex flex-wrap">
                             <!-- Flavor tags inserted by JS -->
                         </div>
                     </div>

                     <!-- Comments Section (positioned within details card) -->
                     <section id="comments-section" class="mt-6 border-t pt-6 hidden">
                         <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3 mb-4">
                             <h3 class="text-xl font-bold text-gray-800" data-i18n="resultsPage.comments.title">其他用户评论区</h3>
                             <span id="comments-count" class="text-sm text-gray-500"></span>
                         </div>
                         <div id="comment-login-prompt" class="hidden mb-4 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3 bg-yellow-100 border border-yellow-200 text-yellow-800 rounded-lg px-4 py-3">
                             <span data-i18n="resultsPage.comments.loginPrompt">请先登录后再发表评论。</span>
                             <button onclick="login()" class="self-start sm:self-center px-3 py-1.5 text-xs font-semibold rounded bg-green-500 text-white hover:bg-green-600 transition" data-i18n="nav.login">登录/注册</button>
                         </div>
                         <div id="comment-muted-message" class="hidden mb-4 bg-red-50 border border-red-200 text-red-600 rounded-lg px-4 py-3 text-sm" data-i18n="resultsPage.comments.muted">您已被禁言，暂时无法发表评论。</div>
                         <div id="comment-form-container" class="mb-6 space-y-2">
                             <textarea id="comment-input" class="w-full border border-gray-200 rounded-lg p-3 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent min-h-[100px] resize-y" data-i18n="resultsPage.comments.placeholder" placeholder="写下你的看法吧..."></textarea>
                             <div class="flex items-center justify-between">
                                 <p id="comment-status-message" class="hidden text-xs"></p>
                                 <button id="comment-submit-button" class="ml-auto px-4 py-2 bg-indigo-600 text-white text-sm font-semibold rounded-lg shadow hover:bg-indigo-700 transition" data-i18n="resultsPage.comments.submit">发布评论</button>
                             </div>
                         </div>
                         <div id="comments-list" class="space-y-4">
                             <p id="comments-empty" class="text-sm text-gray-500" data-i18n="resultsPage.comments.empty">暂时还没有评论，快来抢沙发吧！</p>
                         </div>
                     </section>
                 </div>
            </div>

            <!-- Score Section -->
            <section id="score-section" class="bg-white rounded-xl shadow-lg p-6 mb-8 flex flex-col md:flex-row gap-6 items-center">
                <!-- Score and grade details inserted by JS -->
            </section>

             <!-- Save Button (visible only for drafts) -->
             <div id="save-button-container" class="hidden mb-6">
                 <button id="save-rating-button" onclick="saveRating()" class="w-full py-3 px-6 bg-green-600 text-white font-bold text-lg rounded-lg shadow-md hover:bg-green-700 transition" data-i18n="resultsPage.saveRating">
                     保存为我的评分记录
                 </button>
             </div>

            <!-- Details Sections (Narrative Summary, Rating Details) -->
            <div class="space-y-4">
                 <!-- Narrative Summary -->
                 <details id="narrative-summary-details" class="group bg-white rounded-xl shadow-lg p-6 transition-all duration-300" open>
                     <summary class="flex justify-between items-center cursor-pointer font-bold text-lg text-gray-800">
                         <span>
                             <span data-i18n="resultsPage.narrativeTitle">综合评价</span>
                             <!-- Arrow icon -->
                             <svg class="inline w-5 h-5 transform group-open:rotate-180 transition-transform ml-1" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
                         </span>
                         <!-- Copy Button with Tooltip -->
                         <div class="tooltip">
                             <button id="copy-summary-button" onclick="copySummary(event)" class="ml-4 p-1.5 bg-gray-100 text-gray-600 rounded-full hover:bg-gray-200 transition text-xs">
                                 <!-- Copy icon -->
                                 <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"> <path stroke-linecap="round" stroke-linejoin="round" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /> </svg>
                             </button>
                             <span id="copy-tooltip" class="tooltiptext" data-i18n="resultsPage.copy">复制</span>
                         </div>
                     </summary>
                     <div id="narrative-summary-container" class="mt-4 prose max-w-none">
                         <!-- Narrative summary inserted by JS -->
                     </div>
                 </details>
                 <!-- Rating Details Summary -->
                 <details id="summary-details" class="group bg-white rounded-xl shadow-lg p-6">
                     <summary class="flex justify-between items-center cursor-pointer font-bold text-lg text-gray-800">
                         <span data-i18n="resultsPage.detailsTitle">评分详情汇总</span>
                         <!-- Arrow icon -->
                         <svg class="w-5 h-5 transform group-open:rotate-180 transition-transform" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>
                     </summary>
                     <div id="summary-container" class="mt-4">
                         <!-- Rating details summary inserted by JS -->
                     </div>
                 </details>
            </div>
            <!-- Footer Navigation -->
            <footer class="mt-8 flex flex-col sm:flex-row justify-center items-center gap-4">
                 <a href="rate.html" class="py-3 px-6 bg-indigo-600 text-white font-bold rounded-lg shadow-md hover:bg-indigo-700 transition" data-i18n="resultsPage.backToRate">
                     &larr; 返回重新评分
                 </a>
            </footer>
        </div>

        <!-- Hidden Share Card Container (for image generation) -->
        <div id="share-card-container">
            <div id="share-card-image-wrapper">
                <img id="share-card-image" src="" alt="Cigar Cover Image" crossorigin="anonymous" loading="lazy">
                <div id="share-card-pagination" aria-hidden="true">
                    <span></span>
                    <span></span>
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
            <!-- --- MODIFIED: Share Card Content Structure --- -->
            <div id="share-card-content">
                <div id="share-card-left">
                    <span id="share-card-score">0.00</span>
                    <span id="share-card-grade-badge">? - ???</span>
                    <p id="share-card-watermark">Rating on www.pista-cho.com</p>
                </div>
                <div id="share-card-qrcode">
                    <!-- QR code img will be added here -->
                </div>
            </div>
            <!-- --- End Modified Share Card Content --- -->
        </div>
    </div>

    <script type="module">
        // --- Constants and Global Vars ---
        const GRADING_SCALE = [ // Defines grades, score ranges, and i18n keys
            { "grade": "P", "nameKey": "resultsPage.grade.P", "min_score": 95, "color": "gold" },
            { "grade": "I", "nameKey": "resultsPage.grade.I", "min_score": 90, "color": "indigo" },
            { "grade": "S", "nameKey": "resultsPage.grade.S", "min_score": 80, "color": "purple" },
            { "grade": "T", "nameKey": "resultsPage.grade.T", "min_score": 70, "color": "blue" },
            { "grade": "A", "nameKey": "resultsPage.grade.A", "min_score": 60, "color": "green" },
            { "grade": "C", "nameKey": "resultsPage.grade.C", "min_score": 50, "color": "gray" },
            { "grade": "H", "nameKey": "resultsPage.grade.H", "min_score": 30, "color": "orange" },
            { "grade": "O", "nameKey": "resultsPage.grade.O", "min_score": 0, "color": "red" }
        ];

        let currentAuthUser = null; // Stores logged-in user info
        let resultsData = null;     // Stores the rating data being displayed
        let ratingId = null;        // ID of the rating (if saved)
        const AUTHING_APP_ID = '68f5b0b6875017c02b3bfdb3'; // Authing App ID
        const AUTHING_HOST = 'https://xfvu647mcdbk-demo.authing.cn'; // Authing Host
        let mainSwiper = null;      // Swiper instance for main images
        let thumbnailSwiper = null; // Swiper instance for thumbnails
        let shareImageGenerated = false; // Flag to prevent multiple generations
        let shareImageObjectUrl = null;  // Blob URL for generated share image (better mobile support)
        let shareImageRetryTimer = null; // Timer reference for retry attempts
        const SHARE_IMAGE_MAX_RETRIES = 5; // Limit retries to avoid infinite loops
        const SHARE_IMAGE_RETRY_DELAY = 800; // Base delay (ms) between retries
        const PRODUCTION_ORIGIN = 'https://www.pista-cho.com'; // Canonical domain used for share links
        const DEFAULT_SHARE_DESCRIPTION = '查看 Pistacho 雪茄品鉴报告，回顾完整的评分细节、口感总结与分享卡片。';
        const commentState = {
            comments: [],
            mutedUserIds: new Set(),
            currentUserMuted: false,
            currentUserId: null,
            currentUserRole: 'guest'
        };
        let commentStatusTimer = null;
        let commentSubmitBound = false;

        const RESOURCE_PROMISES = new Map();
        const SWIPER_STYLE_URL = 'https://cdnjs.cloudflare.com/ajax/libs/Swiper/11.0.5/swiper-bundle.min.css';
        const SWIPER_SCRIPT_URL = 'https://cdnjs.cloudflare.com/ajax/libs/Swiper/11.0.5/swiper-bundle.min.js';
        const HTML2CANVAS_SCRIPT_URL = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
        const QRCODE_SCRIPT_URL = 'https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js';

        function toAbsoluteUrl(url) {
            try {
                return new URL(url, document.baseURI).href;
            } catch (error) {
                return url;
            }
        }

        function loadScriptOnce(src, { async = true, defer = true, crossOrigin = 'anonymous' } = {}) {
            if (!src) {
                return Promise.reject(new Error('Script source is required'));
            }

            const normalizedSrc = toAbsoluteUrl(src);
            if (RESOURCE_PROMISES.has(normalizedSrc)) {
                return RESOURCE_PROMISES.get(normalizedSrc);
            }

            const existing = document.querySelector(`script[src="${normalizedSrc}"]`);
            if (existing && existing.dataset.loaded === 'true') {
                return Promise.resolve();
            }

            const promise = new Promise((resolve, reject) => {
                const script = existing || document.createElement('script');
                script.src = normalizedSrc;
                script.async = async;
                script.defer = defer;
                if (crossOrigin) {
                    script.crossOrigin = crossOrigin;
                }
                script.onload = () => {
                    script.dataset.loaded = 'true';
                    resolve();
                };
                script.onerror = () => reject(new Error(`Failed to load script: ${src}`));
                if (!existing) {
                    document.head.appendChild(script);
                }
            });

            RESOURCE_PROMISES.set(normalizedSrc, promise);
            return promise;
        }

        function loadStylesheetOnce(href) {
            if (!href) {
                return Promise.reject(new Error('Stylesheet href is required'));
            }

            const normalizedHref = toAbsoluteUrl(href);
            if (RESOURCE_PROMISES.has(normalizedHref)) {
                return RESOURCE_PROMISES.get(normalizedHref);
            }

            const existing = Array.from(document.querySelectorAll('link[rel="stylesheet"], link[data-lazy-stylesheet="true"]'))
                .find(link => link.href === normalizedHref);
            if (existing && existing.dataset.loaded === 'true') {
                return Promise.resolve();
            }

            const promise = new Promise((resolve, reject) => {
                const link = existing || document.createElement('link');
                link.rel = 'stylesheet';
                link.href = normalizedHref;
                link.onload = () => {
                    link.dataset.loaded = 'true';
                    resolve();
                };
                link.onerror = () => reject(new Error(`Failed to load stylesheet: ${href}`));
                if (!existing) {
                    link.setAttribute('data-lazy-stylesheet', 'true');
                    document.head.appendChild(link);
                }
            });

            RESOURCE_PROMISES.set(normalizedHref, promise);
            return promise;
        }

        async function ensureSwiper() {
            if (typeof Swiper !== 'undefined') {
                return Swiper;
            }
            await Promise.all([loadStylesheetOnce(SWIPER_STYLE_URL), loadScriptOnce(SWIPER_SCRIPT_URL)]);
            if (typeof Swiper === 'undefined') {
                throw new Error('Swiper failed to load');
            }
            return Swiper;
        }

        async function ensureHtml2Canvas() {
            if (typeof html2canvas !== 'undefined') {
                return html2canvas;
            }
            await loadScriptOnce(HTML2CANVAS_SCRIPT_URL);
            if (typeof html2canvas === 'undefined') {
                throw new Error('html2canvas failed to load');
            }
            return html2canvas;
        }

        async function ensureQRCode() {
            if (typeof QRCode !== 'undefined') {
                return QRCode;
            }
            await loadScriptOnce(QRCODE_SCRIPT_URL);
            if (typeof QRCode === 'undefined') {
                throw new Error('QRCode library failed to load');
            }
            return QRCode;
        }

        function resolveFinalGrade(rawFinalGrade, normalizedScore) {
            const existing = rawFinalGrade ? { ...rawFinalGrade } : null;
            let gradeCode = existing?.grade;
            let matchedGrade = null;

            if (gradeCode) {
                matchedGrade = GRADING_SCALE.find(g => g.grade === gradeCode) || null;
            }

            if (!matchedGrade && typeof normalizedScore === 'number') {
                matchedGrade = GRADING_SCALE.find(g => normalizedScore >= g.min_score) || GRADING_SCALE[GRADING_SCALE.length - 1];
                if (!gradeCode && matchedGrade) {
                    gradeCode = matchedGrade.grade;
                }
            }

            if (!matchedGrade) {
                return existing;
            }

            const resolved = {
                ...existing,
                grade: gradeCode || matchedGrade.grade,
                nameKey: existing?.nameKey || matchedGrade.nameKey,
                color: existing?.color || matchedGrade.color
            };

            if (existing?.name_cn && !resolved.name_cn) {
                resolved.name_cn = existing.name_cn;
            }

            if (!resolved.name && resolved.name_cn) {
                resolved.name = resolved.name_cn;
            }

            return resolved;
        }

        function normalizeResultsData(rawData) {
            if (!rawData || typeof rawData !== 'object') {
                return rawData;
            }

            const data = { ...rawData };

            if (!data.ratingId && data.id) {
                data.ratingId = data.id;
            }

            if (data.fullData && typeof data.fullData === 'string') {
                try { data.fullData = JSON.parse(data.fullData); }
                catch (e) { console.warn('[results.html normalizeResultsData] Failed to parse fullData string:', e); data.fullData = null; }
            }

            const imageCandidates = [];
            if (Array.isArray(data.imageUrls)) {
                imageCandidates.push(...data.imageUrls);
            } else if (Array.isArray(data.imageUrl)) {
                imageCandidates.push(...data.imageUrl);
            } else if (typeof data.imageUrl === 'string' && data.imageUrl.trim() !== '') {
                try {
                    const parsed = JSON.parse(data.imageUrl);
                    if (Array.isArray(parsed)) imageCandidates.push(...parsed);
                    else imageCandidates.push(data.imageUrl);
                } catch (e) {
                    imageCandidates.push(data.imageUrl);
                }
            }
            data.imageUrls = imageCandidates.filter(key => typeof key === 'string' && key.trim() !== '');

            const fullData = (data.fullData && typeof data.fullData === 'object') ? data.fullData : null;
            if (fullData) {
                if (!data.config && fullData.config) data.config = fullData.config;
                if (!data.ratings && fullData.ratings) data.ratings = fullData.ratings;
                if (data.calculatedScore === undefined && fullData.calculatedScore !== undefined) data.calculatedScore = fullData.calculatedScore;
                if ((!Array.isArray(data.selectedFlavors) || data.selectedFlavors.length === 0) && Array.isArray(fullData.selectedFlavors)) {
                    data.selectedFlavors = fullData.selectedFlavors;
                }
                if (!data.cigarReview && fullData.cigarReview) data.cigarReview = fullData.cigarReview;
                if (!data.finalGrade && fullData.finalGrade) data.finalGrade = fullData.finalGrade;
                if (fullData.cigarInfo) {
                    const info = fullData.cigarInfo;
                    const existing = data.cigarInfo && typeof data.cigarInfo === 'object' ? data.cigarInfo : {};
                    data.cigarInfo = {
                        name: existing.name ?? info.name ?? data.cigarName ?? null,
                        size: existing.size ?? info.size ?? data.cigarSize ?? null,
                        origin: existing.origin ?? info.origin ?? data.cigarOrigin ?? null
                    };
                }
            }

            if (!data.cigarInfo || typeof data.cigarInfo !== 'object') {
                data.cigarInfo = {
                    name: data.cigarName ?? null,
                    size: data.cigarSize ?? null,
                    origin: data.cigarOrigin ?? null
                };
            } else {
                data.cigarInfo = {
                    name: data.cigarInfo.name ?? data.cigarName ?? null,
                    size: data.cigarInfo.size ?? data.cigarSize ?? null,
                    origin: data.cigarInfo.origin ?? data.cigarOrigin ?? null
                };
            }

            if (!Array.isArray(data.selectedFlavors)) {
                data.selectedFlavors = Array.isArray(data.fullData?.selectedFlavors) ? data.fullData.selectedFlavors : [];
            }

            if (!data.finalGrade && data.finalGrade_grade) {
                data.finalGrade = { grade: data.finalGrade_grade, name_cn: data.finalGrade_name_cn };
            }

            return data;
        }

        // --- i18n Initialization Functions ---
        async function initI18n() {
            // Initialize i18next
            await i18next
                .use(i18nextHttpBackend)
                .use(i18nextBrowserLanguageDetector)
                .init({
                    fallbackLng: 'zh',
                    debug: false, // Turn off for production
                    ns: ['translation'],
                    defaultNS: 'translation',
                    backend: {
                        loadPath: '/locales/{{lng}}.json?v=1' // Cache busting
                    },
                    detection: {
                        order: ['localStorage', 'navigator'],
                        caches: ['localStorage']
                    }
                });
            // Update static text after init
            // Note: Document title is set in updateContent after language detection
        }

        function updateContent() {
            // Update elements with data-i18n attribute
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                let value = '';
                try {
                    value = i18next.t(key);
                    if (value === key && key !== '') console.warn(`Translation missing for key: ${key}`);
                } catch (e) { console.error(`Error translating key "${key}":`, e); value = `[Error: ${key}]`; }

                if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
                    if (el.hasAttribute('placeholder')) el.placeholder = value;
                } else if (el.tagName === 'OPTION') {
                    el.textContent = value;
                } else {
                    // Handle specific elements like tooltip
                    if (el.id === 'copy-tooltip') {
                         el.textContent = value;
                    } else {
                         el.innerHTML = value; // Use innerHTML for others
                    }
                }
            });
            // Update page title
            document.title = i18next.t('resultsPage.pageTitle');
            renderCommentsSection();
            updateCommentFormState();
        }


        function renderLanguageSwitcher() {
            const container = document.getElementById('language-flags');
            if (!container || !i18next.isInitialized) return;
            container.innerHTML = '';
            const languages = ['zh', 'en', 'es'];
            const currentLang = i18next.language ? i18next.language.split('-')[0] : 'zh';

            languages.forEach(lang => {
                const button = document.createElement('button');
                button.textContent = lang.toUpperCase();
                button.className = `lang-button ${lang === currentLang ? 'active' : ''}`;
                button.dataset.lang = lang;
                button.onclick = async (e) => {
                    const newLang = e.target.dataset.lang;
                    const oldLang = i18next.language ? i18next.language.split('-')[0] : 'zh';
                    if (newLang === oldLang) return;
                    try {
                        await i18next.changeLanguage(newLang);
                        updateContent();
                        renderLanguageSwitcher();
                        renderLoginStatus(currentAuthUser);
                        if (resultsData) {
                            renderPageContent(resultsData);
                            populateShareCard(resultsData);
                            await generateQRCode();
                            renderCommentsSection();
                            updateCommentFormState();
                        }
                    } catch (langErr) {
                        console.error(`Failed to change language to ${newLang}:`, langErr);
                    }
                };
                container.appendChild(button);
            });
        }

        document.addEventListener('navbar:loaded', () => {
            renderLanguageSwitcher();
            renderLoginStatus(currentAuthUser);
        });

        // --- Authentication ---
        // Redirects to Authing for login
        window.login = function() {
            const redirectUri = window.location.origin; // Use base origin
            const authorizeUrl = new URL('/oidc/auth', AUTHING_HOST);
            authorizeUrl.search = new URLSearchParams({
                client_id: AUTHING_APP_ID,
                redirect_uri: redirectUri,
                response_type: 'code',
                scope: 'openid profile email phone',
                state: Math.random().toString(36).substring(2)
            }).toString();
            window.location.href = authorizeUrl.toString();
        }

        // Redirects to Authing for logout
        window.logout = function() {
            const logoutUrl = new URL('/oidc/session/end', AUTHING_HOST);
            logoutUrl.search = new URLSearchParams({ post_logout_redirect_uri: window.location.origin }).toString();
            sessionStorage.removeItem('userInfo');
            sessionStorage.removeItem('accessToken');
            window.location.href = logoutUrl.toString();
        }

        // Updates UI based on login status
        function renderLoginStatus(user) {
            const container = document.getElementById('login-status-container');
            if (!container || !i18next.isInitialized) return;
            if (user) {
                const displayName = user.nickname || user.name || user.preferred_username || user.email || i18next.t('nav.loggedIn');
                container.innerHTML = `<span class="text-sm font-medium text-gray-700 mr-2 hidden sm:inline">${displayName}</span><button onclick="logout()" class="px-3 py-1 text-xs font-medium rounded-full bg-red-500 text-white hover:bg-red-600">${i18next.t('nav.logout')}</button>`;
            } else {
                container.innerHTML = `<button onclick="login()" class="px-3 py-1 text-xs font-medium rounded-full bg-green-500 text-white hover:bg-green-600">${i18next.t('nav.login')}</button>`;
            }
        }

        // Handles the OIDC callback after login
        async function handleOidcCallback(code) {
            try {
                const redirectUri = window.location.origin; // Use base origin
                const apiUrl = new URL('/api/authing/callback', window.location.origin);
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ code: code, redirect_uri: redirectUri }) });
                if (!response.ok) {
                    let errorText = i18next.t('errors.authCallbackFailed', { status: response.status });
                    try { const err = await response.json(); errorText = err.error || errorText; } catch(e){}
                    throw new Error(errorText);
                }
                const fullUserProfile = await response.json();
                sessionStorage.setItem('userInfo', JSON.stringify(fullUserProfile));
                sessionStorage.setItem('accessToken', fullUserProfile.accessToken);
                return fullUserProfile;
            } catch (e) {
                console.error('Authentication callback handling failed:', e);
                alert(i18next.t('errors.loginFailed', { message: e.message }));
                sessionStorage.removeItem('userInfo');
                sessionStorage.removeItem('accessToken');
                return null;
            } finally {
                // Clean URL
                // Keep search params like ?ratingId=... but remove code/state
                const cleanSearch = window.location.search
                    .replace(/&?code=[^&]*/, '')
                    .replace(/&?state=[^&]*/, '')
                    .replace(/^\?&/, '?') // Handle case where ? is followed by &
                    .replace(/&$/, '');   // Remove trailing &
                const cleanUrl = window.location.pathname + (cleanSearch !== '?' ? cleanSearch : ''); // Avoid leaving just '?'
                window.history.replaceState({}, document.title, cleanUrl);
            }
        }
        // Validates session token with backend
        async function validateSessionAndGetUser() {
            const token = sessionStorage.getItem('accessToken');
            if (!token) return null;
            try {
                const apiUrl = new URL('/api/me', window.location.origin);
                const response = await fetch(apiUrl, { headers: { 'Authorization': `Bearer ${token}` } });
                if (!response.ok) {
                    sessionStorage.removeItem('userInfo'); sessionStorage.removeItem('accessToken'); return null;
                }
                const fullUserProfile = await response.json();
                sessionStorage.setItem('userInfo', JSON.stringify(fullUserProfile));
                return fullUserProfile;
            } catch (e) { console.error("Session validation failed:", e); return null; }
        }

        // --- Main Functions ---
        // Handles saving the rating (only if it's a draft)
        window.saveRating = async function() {
            const token = sessionStorage.getItem('accessToken');
            if (!currentAuthUser || !token) { // Check login
                return alert(i18next.t('common.loginRequired'));
            }
            // Check if it's a draft (data came from sessionStorage via rate.html)
            // Need to check resultsData directly as it holds the loaded data state
            if (!resultsData || !resultsData.isDraft) {
                return alert(i18next.t('errors.notADraft'));
            }

            const button = document.getElementById('save-rating-button');
            button.textContent = i18next.t('common.saving'); // Update button text
            button.disabled = true;

            try {
                // Ensure resultsData contains all necessary fields before sending
                if (!resultsData.title || !resultsData.config || !resultsData.ratings || resultsData.calculatedScore === undefined) {
                     throw new Error("Cannot save rating: Data is incomplete.");
                }

                const apiUrl = new URL('/api/ratings', window.location.origin);
                const response = await fetch(apiUrl, {
                    method: 'POST', // Use POST to create a new rating entry
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
                    body: JSON.stringify(resultsData) // Send the complete resultsData object
                });
                if (!response.ok) {
                    let errorText = i18next.t('errors.saveFailedNoMsg');
                    try { const err = await response.json(); errorText = err.error || errorText; } catch(e){}
                    throw new Error(errorText);
                }
                const saveResult = await response.json();
                const newRatingId = saveResult.id; // Get the newly assigned ID from the backend

                alert(i18next.t('common.saveSuccess'));
                sessionStorage.removeItem('cigarRatingResults'); // Clear draft from session

                // Update button state to indicate success
                button.textContent = i18next.t('common.saveSuccess');
                button.classList.remove('bg-green-600', 'hover:bg-green-700');
                button.classList.add('bg-gray-400', 'cursor-not-allowed');

                // Update state if new ID is received
                if (newRatingId) {
                    ratingId = newRatingId; // Store the new ID globally
                    resultsData.isDraft = false; // Mark as no longer a draft

                    // Update URL with the new rating ID without reloading
                    const newUrl = new URL(window.location.href);
                    newUrl.searchParams.set('ratingId', newRatingId);
                    window.history.replaceState({}, document.title, newUrl.toString());

                    // Re-render to hide the save button based on isDraft=false
                    // Also regenerate QR code with the final URL
                    renderPageContent(resultsData); // Call renderPageContent again to hide the button
                    await generateQRCode(); // Regenerate QR for the new URL (await for share card)

                    // Try generating share image again now that we have the final ID/URL
                    shareImageGenerated = false; // Reset flag
                    tryAutoGenerateShareImage(); // Attempt generation
                }
            } catch (e) {
                console.error("保存评分失败:", e);
                alert(i18next.t('common.saveFailed', { msg: e.message }));
                // Reset button state on failure
                button.textContent = i18next.t('resultsPage.saveRating');
                button.disabled = false;
            }
        };


        // Copies the narrative summary text to the clipboard
        window.copySummary = function(event) {
            event.preventDefault(); // Prevent details section from toggling
            event.stopPropagation(); // Stop event bubbling
            const summaryContainer = document.getElementById('narrative-summary-container');
            const summaryText = summaryContainer ? summaryContainer.innerText || summaryContainer.textContent : ''; // Get text content
            const tooltip = document.getElementById('copy-tooltip');
            navigator.clipboard.writeText(summaryText.trim()).then(() => {
                tooltip.textContent = i18next.t('common.copied'); // Show 'Copied!'
                setTimeout(() => { tooltip.textContent = i18next.t('resultsPage.copy'); }, 2000); // Reset after 2s
            }, (err) => {
                console.error('Could not copy text: ', err);
                tooltip.textContent = i18next.t('common.copyFailed'); // Show 'Copy failed'
                setTimeout(() => { tooltip.textContent = i18next.t('resultsPage.copy'); }, 2000); // Reset after 2s
            });
        };

        // Initializes the Swiper image galleries (main and thumbnails)
        async function initSwipers(imageUrls = []) {
             const mainWrapper = document.getElementById('main-swiper-wrapper');
             const thumbWrapper = document.getElementById('thumbnail-swiper-wrapper');
             const thumbContainer = document.querySelector('.thumbnail-swiper');
             if (!mainWrapper || !thumbWrapper || !thumbContainer) {
                 console.warn('[results.html initSwipers] Missing swiper containers.');
                 return;
             }

             const normalizedImages = Array.isArray(imageUrls) ? imageUrls : [];

             mainWrapper.innerHTML = '';
             thumbWrapper.innerHTML = '';

             if (normalizedImages.length === 0) {
                 mainWrapper.innerHTML = `<div class="swiper-slide flex items-center justify-center text-gray-400 aspect-[1179/1572]">${i18next.t('common.noImage')}</div>`;
                 thumbContainer.classList.add('hidden');
                 if (mainSwiper) mainSwiper.destroy(true, true);
                 if (thumbnailSwiper) thumbnailSwiper.destroy(true, true);
                 mainSwiper = null;
                 thumbnailSwiper = null;
                 return;
             }

             normalizedImages.forEach(key => {
                 const imageUrl = `/api/image/${key}`;
                 const imgElement = `<img src="${imageUrl}" alt="${i18next.t('common.cigarImageAlt')}" crossorigin="anonymous" loading="lazy" onerror="this.src='https://placehold.co/600x800/gray/white?text=Loading+Failed'; this.onerror=null;">`;
                 mainWrapper.innerHTML += `<div class="swiper-slide">${imgElement}</div>`;
                 thumbWrapper.innerHTML += `<div class="swiper-slide thumbnail-slide">${imgElement}</div>`;
             });

             if (mainSwiper) mainSwiper.destroy(true, true);
             if (thumbnailSwiper) thumbnailSwiper.destroy(true, true);

             let swiperReady = typeof Swiper !== 'undefined';
             if (!swiperReady) {
                 try {
                     await ensureSwiper();
                     swiperReady = typeof Swiper !== 'undefined';
                 } catch (error) {
                     console.error('[results.html initSwipers] Failed to load Swiper library:', error);
                     thumbContainer.classList.add('hidden');
                     mainSwiper = null;
                     thumbnailSwiper = null;
                     return;
                 }
             }

             const hasMultipleItems = normalizedImages.length > 1;

             if (hasMultipleItems && !shareImageGenerated) {
                 thumbContainer.classList.remove('hidden');
                 thumbnailSwiper = new Swiper('.thumbnail-swiper', {
                     spaceBetween: 10,
                     slidesPerView: 'auto',
                     freeMode: true,
                     watchSlidesProgress: true,
                 });
             } else {
                 thumbContainer.classList.add('hidden');
                 thumbnailSwiper = null;
             }

             mainSwiper = new Swiper('.main-swiper', {
                 spaceBetween: 10,
                 autoHeight: true,
                 navigation: { nextEl: '.swiper-button-next', prevEl: '.swiper-button-prev' },
                 pagination: { el: '.main-swiper .swiper-pagination', clickable: true },
                 thumbs: { swiper: thumbnailSwiper },
                 allowTouchMove: !(normalizedImages.length === 1 && !shareImageGenerated),
             });
        }

        // Function to check if image is loaded
        function isImageLoaded(imgElement) {
            return imgElement && imgElement.complete && imgElement.naturalWidth !== 0;
        }

        // Waits for images, generates share card, adds to main AND thumb swiper
        async function autoGenerateShareImage() {
            if (shareImageGenerated) return true;

            const shareCardElement = document.getElementById('share-card-container');
            const coverImageElement = document.getElementById('share-card-image');
            const qrCodeContainer = document.getElementById('share-card-qrcode');
            const mainSwiperWrapper = document.getElementById('main-swiper-wrapper');
            const thumbSwiperWrapper = document.getElementById('thumbnail-swiper-wrapper');
            const thumbContainer = document.querySelector('.thumbnail-swiper');

            if (!shareCardElement || !coverImageElement || !qrCodeContainer || !thumbSwiperWrapper || !thumbContainer || !resultsData || !mainSwiperWrapper) {
                console.warn("Cannot auto-generate share image: Missing required elements or libraries.");
                return false;
            }

            let html2canvasInstance;
            try {
                html2canvasInstance = await ensureHtml2Canvas();
            } catch (error) {
                console.error('Failed to load html2canvas for share image generation.', error);
                return false;
            }

            let swiperAvailable = typeof Swiper !== 'undefined';
            if (!swiperAvailable) {
                try {
                    await ensureSwiper();
                    swiperAvailable = typeof Swiper !== 'undefined';
                } catch (error) {
                    console.warn('[results.html autoGenerateShareImage] Swiper not available, proceeding without slider updates.', error);
                    swiperAvailable = false;
                }
            }

            const coverImagePromise = new Promise((resolve, reject) => {
                if (isImageLoaded(coverImageElement)) { resolve(); }
                else if (!coverImageElement.src || coverImageElement.src.includes('placehold.co')) { resolve('no-cover'); }
                else { coverImageElement.onload = resolve; coverImageElement.onerror = () => reject(new Error('Cover image failed to load for share card.')); }
            });
            const qrCodeImagePromise = new Promise((resolve, reject) => {
                 const qrImg = qrCodeContainer.querySelector('img');
                 if (isImageLoaded(qrImg)) { resolve(); }
                 else if (qrImg) { qrImg.onload = resolve; qrImg.onerror = () => reject(new Error('QR code image failed to load for share card.')); }
                 else { resolve('no-qr-img'); }
            });

            const statusElement = document.getElementById('loading-indicator');
            try {
                 if (statusElement) {
                     statusElement.textContent = i18next.t('resultsPage.shareCard.generating');
                     statusElement.classList.remove('hidden');
                 }

                 console.log("Waiting for share card images (cover & QR)...");
                 const [coverStatus] = await Promise.all([coverImagePromise, qrCodeImagePromise]);
                 console.log("Share card images ready.");

                 if (coverStatus === 'no-cover') {
                      console.warn("Skipping share image generation because cover image is missing or invalid.");
                      if (statusElement) statusElement.classList.add('hidden');
                      return false;
                 }

                 shareCardElement.style.visibility = 'visible';
                 await new Promise(resolve => setTimeout(resolve, 300));

                 const canvas = await html2canvasInstance(shareCardElement, { useCORS: true, allowTaint: true, scale: 2 });

                 let imageSrc = null;
                 if (typeof canvas.toBlob === 'function') {
                     try {
                         const blob = await new Promise((resolve, reject) => {
                             canvas.toBlob(result => {
                                 if (result) resolve(result);
                                 else reject(new Error('Failed to create blob from share image canvas.'));
                             }, 'image/png');
                         });
                         if (shareImageObjectUrl) {
                             URL.revokeObjectURL(shareImageObjectUrl);
                         }
                         shareImageObjectUrl = URL.createObjectURL(blob);
                         imageSrc = shareImageObjectUrl;
                     } catch (blobError) {
                         console.warn('Failed to use Blob for share image, falling back to data URL.', blobError);
                     }
                 }

                 if (!imageSrc) {
                     imageSrc = canvas.toDataURL('image/png');
                 }

                 const newMainSlide = document.createElement('div');
                 newMainSlide.className = 'swiper-slide share-image-slide';
                 newMainSlide.innerHTML = `<img src="${imageSrc}" alt="${i18next.t('resultsPage.shareImageAlt')}">`;
                 mainSwiperWrapper.appendChild(newMainSlide);

                 const newThumbSlide = document.createElement('div');
                 newThumbSlide.className = 'swiper-slide thumbnail-slide share-thumb-slide';
                 newThumbSlide.innerHTML = `<img src="${imageSrc}" alt="${i18next.t('resultsPage.shareThumb')}">`;
                 thumbSwiperWrapper.appendChild(newThumbSlide);

                 if (swiperAvailable) {
                     if (mainSwiper) mainSwiper.update();
                     if (thumbnailSwiper) {
                          thumbnailSwiper.update();
                          thumbContainer.classList.remove('hidden');
                     } else if (resultsData.imageUrls && resultsData.imageUrls.length >= 0) {
                          thumbContainer.classList.remove('hidden');
                          thumbnailSwiper = new Swiper('.thumbnail-swiper', {
                               spaceBetween: 10,
                               slidesPerView: 'auto',
                               freeMode: true,
                               watchSlidesProgress: true,
                          });
                          if (mainSwiper) {
                              if (!mainSwiper.thumbs) mainSwiper.thumbs = {};
                              mainSwiper.thumbs.swiper = thumbnailSwiper;
                              mainSwiper.thumbs.init();
                              mainSwiper.thumbs.update(true);
                          }
                     }
                     if (mainSwiper && !mainSwiper.params.allowTouchMove) {
                         mainSwiper.params.allowTouchMove = true;
                         mainSwiper.allowTouchMove = true;
                     }
                 } else {
                     thumbContainer.classList.remove('hidden');
                 }

                 shareImageGenerated = true;
                 console.log("Share image generated and added to sliders.");
                 return true;

            } catch (error) {
                 console.error(i18next.t('resultsPage.shareCard.generateFailed'), error);
                 if (statusElement) {
                     statusElement.textContent = `${i18next.t('resultsPage.shareCard.generateFailed')} ${error.message}`;
                 }
                 return false;
            } finally {
                 shareCardElement.style.visibility = 'hidden';
                 if (statusElement) {
                     setTimeout(() => { statusElement.classList.add('hidden'); }, 3000);
                 }
            }
        }


        // Helper to attempt share image generation safely
        async function tryAutoGenerateShareImage(retryCount = 0) {
            if (shareImageGenerated || !resultsData) return;

            const shareImg = document.getElementById('share-card-image');
            if (!shareImg || !shareImg.src || shareImg.src.includes('placehold.co')) {
                console.log("Skipping auto-generation: No valid cover image set for share card yet.");
                if (retryCount < SHARE_IMAGE_MAX_RETRIES) {
                    if (shareImageRetryTimer) clearTimeout(shareImageRetryTimer);
                    shareImageRetryTimer = setTimeout(() => tryAutoGenerateShareImage(retryCount + 1), SHARE_IMAGE_RETRY_DELAY);
                }
                return;
            }

            try {
                await ensureHtml2Canvas();
            } catch (error) {
                console.log("html2canvas not ready, will retry share image generation.", error);
                if (retryCount < SHARE_IMAGE_MAX_RETRIES) {
                    if (shareImageRetryTimer) clearTimeout(shareImageRetryTimer);
                    shareImageRetryTimer = setTimeout(() => tryAutoGenerateShareImage(retryCount + 1), SHARE_IMAGE_RETRY_DELAY);
                }
                return;
            }

            const success = await autoGenerateShareImage();
            if (success) {
                if (shareImageRetryTimer) {
                    clearTimeout(shareImageRetryTimer);
                    shareImageRetryTimer = null;
                }
            } else if (retryCount < SHARE_IMAGE_MAX_RETRIES) {
                const backoffDelay = SHARE_IMAGE_RETRY_DELAY * Math.max(1, retryCount + 1);
                if (shareImageRetryTimer) clearTimeout(shareImageRetryTimer);
                shareImageRetryTimer = setTimeout(() => tryAutoGenerateShareImage(retryCount + 1), backoffDelay);
            }
        }

        // Populates the hidden share card elements
        function populateShareCard(data) {
             if (!data || !i18next.isInitialized) return;
             const { normalizedScore, userNickname, userEmail, imageUrls = [] } = data;
             const rawFinalGrade = data.finalGrade ?? (data.finalGrade_grade ? { grade: data.finalGrade_grade, name_cn: data.finalGrade_name_cn } : null);
             const finalGrade = resolveFinalGrade(rawFinalGrade, normalizedScore);
             data.finalGrade = finalGrade;
             // Robust check for finalGrade
             if (!finalGrade || typeof finalGrade !== 'object' || !finalGrade.grade || !finalGrade.nameKey || !finalGrade.color) {
                  console.warn("populateShareCard: finalGrade data missing or incomplete. Cannot populate share card grade.", finalGrade);
                  document.getElementById('share-card-score').textContent = normalizedScore?.toFixed(2) ?? '?.??';
                  document.getElementById('share-card-grade-badge').textContent = i18next.t('common.unrated');
                  document.getElementById('share-card-grade-badge').className = 'inline-block px-1 py-0.5 rounded-full text-xs font-semibold bg-gray-300 text-gray-800 bg-opacity-20';
             } else {
                  const gradeName = i18next.t(finalGrade.nameKey);
                  const gradeStyles = getGradeStyles(finalGrade.color);
                  const scoreEl = document.getElementById('share-card-score');
                  const gradeEl = document.getElementById('share-card-grade-badge');
                  scoreEl.className = `font-black ${gradeStyles.textColor}`; // Apply color class
                  scoreEl.textContent = normalizedScore.toFixed(2);
                  gradeEl.className = `inline-block px-1 py-0.5 rounded-full text-xs font-semibold ${gradeStyles.bgColor} ${gradeStyles.textColor} bg-opacity-20`;
                  gradeEl.textContent = gradeName;
             }

            const watermarkEl = document.getElementById('share-card-watermark');
            if (watermarkEl) {
                 watermarkEl.textContent = 'Rating on www.pista-cho.com';
            }

            const shareCardImage = document.getElementById('share-card-image');
            const shareCardImageWrapper = document.getElementById('share-card-image-wrapper');
            if (imageUrls.length > 0) {
                  shareCardImage.src = `/api/image/${imageUrls[0]}`;
                  shareCardImage.style.display = 'block';
                  shareCardImageWrapper.classList.remove('no-image');
                  const placeholder = shareCardImageWrapper.querySelector('.share-card-placeholder');
                  if (placeholder) placeholder.remove();
            } else {
                  shareCardImage.src = '';
                  shareCardImage.style.display = 'none';
                  shareCardImageWrapper.classList.add('no-image');
                  if (!shareCardImageWrapper.querySelector('.share-card-placeholder')) {
                      const placeholder = document.createElement('span');
                      placeholder.className = 'share-card-placeholder text-gray-400 text-sm';
                      placeholder.textContent = i18next.t('resultsPage.shareCard.noCover');
                      shareCardImageWrapper.appendChild(placeholder);
                  }
            }
        }

        function buildShareUrl() {
            if (ratingId) {
                try {
                    const productionUrl = new URL('/results.html', PRODUCTION_ORIGIN);
                    productionUrl.searchParams.set('ratingId', ratingId);
                    return productionUrl.toString();
                } catch (err) {
                    console.warn('[results.html buildShareUrl] Failed to build production URL, falling back to current origin.', err);
                }
            }

            try {
                const currentUrl = new URL(window.location.href);
                if (ratingId && !currentUrl.searchParams.get('ratingId')) {
                    currentUrl.searchParams.set('ratingId', ratingId);
                }
                return currentUrl.toString();
            } catch (err) {
                console.warn('[results.html buildShareUrl] Failed to parse window.location.href, using canonical domain.', err);
                if (ratingId) {
                    return `${PRODUCTION_ORIGIN}/results.html?ratingId=${encodeURIComponent(ratingId)}`;
                }
                return `${PRODUCTION_ORIGIN}/results.html`;
            }
        }

        function getCanonicalOrigin() {
            try {
                if (window.location && window.location.origin && window.location.origin !== 'null') {
                    return window.location.origin;
                }
            } catch (error) {
                console.warn('[results.html getCanonicalOrigin] Unable to read window.location.origin, using production origin.', error);
            }
            return PRODUCTION_ORIGIN;
        }

        function ensureAbsoluteUrl(pathOrUrl) {
            if (!pathOrUrl) return null;
            try {
                return new URL(pathOrUrl).toString();
            } catch (error) {
                const origin = getCanonicalOrigin();
                if (!origin) return pathOrUrl;
                const sanitizedPath = pathOrUrl.startsWith('/') ? pathOrUrl : `/${pathOrUrl.replace(/^\//, '')}`;
                return `${origin.replace(/\/$/, '')}${sanitizedPath}`;
            }
        }

        function resolveShareImageUrl(imageEntry) {
            if (!imageEntry) {
                return ensureAbsoluteUrl('Certifiedstamp.png');
            }

            if (typeof imageEntry !== 'string') {
                return ensureAbsoluteUrl('Certifiedstamp.png');
            }

            if (/^https?:\/\//i.test(imageEntry)) {
                return imageEntry;
            }

            if (imageEntry.startsWith('/')) {
                return ensureAbsoluteUrl(imageEntry);
            }

            return ensureAbsoluteUrl(`/api/image/${imageEntry}`);
        }

        function setOrCreateMetaTag(attributeName, attributeValue, content) {
            if (!attributeName || !attributeValue) return;
            let selector = `meta[${attributeName}="${attributeValue}"]`;
            let tag = document.head.querySelector(selector);
            if (!tag) {
                tag = document.createElement('meta');
                tag.setAttribute(attributeName, attributeValue);
                document.head.appendChild(tag);
            }
            if (content !== undefined && content !== null) {
                tag.setAttribute('content', content);
            }
        }

        function updatePageMetadata(metaData) {
            if (!metaData || !i18next.isInitialized) return;

            const titleText = metaData.title || i18next.t('common.noTitle');
            const shareTitle = `${titleText} - Pistacho`;
            document.title = shareTitle;

            const normalizedScore = typeof metaData.normalizedScore === 'number'
                ? metaData.normalizedScore.toFixed(2)
                : null;
            let gradeLabel = null;
            if (metaData.finalGrade) {
                if (metaData.finalGrade.nameKey) {
                    gradeLabel = i18next.t(metaData.finalGrade.nameKey);
                } else if (metaData.finalGrade.name_cn || metaData.finalGrade.name) {
                    gradeLabel = metaData.finalGrade.name_cn || metaData.finalGrade.name;
                }
            }

            const descriptionParts = [];
            if (metaData.cigarInfo?.name) {
                descriptionParts.push(metaData.cigarInfo.name);
            }
            if (gradeLabel && normalizedScore) {
                descriptionParts.push(`${gradeLabel} · ${normalizedScore}`);
            } else if (gradeLabel) {
                descriptionParts.push(gradeLabel);
            } else if (normalizedScore) {
                descriptionParts.push(`评分 ${normalizedScore}`);
            }
            const reviewer = metaData.userNickname || metaData.userEmail;
            if (reviewer) {
                descriptionParts.push(`${i18next.t('resultsPage.by', { defaultValue: '点评来自:' })} ${reviewer}`);
            }

            const shareDescription = descriptionParts.join(' | ') || DEFAULT_SHARE_DESCRIPTION;
            const shareImage = resolveShareImageUrl(Array.isArray(metaData.imageUrls) && metaData.imageUrls.length > 0 ? metaData.imageUrls[0] : null);
            const shareUrl = buildShareUrl();

            setOrCreateMetaTag('name', 'description', shareDescription);
            setOrCreateMetaTag('property', 'og:title', shareTitle);
            setOrCreateMetaTag('property', 'og:description', shareDescription);
            setOrCreateMetaTag('property', 'og:image', shareImage);
            setOrCreateMetaTag('property', 'og:url', shareUrl);
            setOrCreateMetaTag('name', 'twitter:title', shareTitle);
            setOrCreateMetaTag('name', 'twitter:description', shareDescription);
            if (shareImage) {
                setOrCreateMetaTag('name', 'twitter:image', shareImage);
            }
        }

        // Generates QR code and resolves promise on image load/error
        async function generateQRCode() {
            const qrCodeContainer = document.getElementById('share-card-qrcode');
            if (!qrCodeContainer) {
                return;
            }

            try {
                await ensureQRCode();
            } catch (error) {
                console.error('[results.html generateQRCode] Failed to load QRCode library:', error);
                qrCodeContainer.innerHTML = `<p class="text-2xs text-red-500">QR Error</p>`;
                throw error;
            }

            return new Promise((resolve, reject) => {
                 const qrCodeContainerInner = document.getElementById('share-card-qrcode');
                 if (qrCodeContainerInner && typeof QRCode !== 'undefined') {
                    qrCodeContainerInner.innerHTML = '';
                    // Use ratingId if available (after save or loaded), otherwise use current page URL (for draft)
                    const uniqueUrl = buildShareUrl();
                    console.log("[results.html generateQRCode] Generating QR for URL:", uniqueUrl); // Log the URL
                    try {
                         new QRCode(qrCodeContainerInner, {
                             text: uniqueUrl, width: 100, height: 100, // Larger QR code for easier scanning
                             colorDark : "#000000", colorLight : "#ffffff",
                             correctLevel : QRCode.CorrectLevel.H
                         });
                         const qrImg = qrCodeContainerInner.querySelector('img');
                         if (qrImg) {
                             const finish = (value, asError = false) => {
                                 if (finish.handled) return;
                                 finish.handled = true;
                                 if (finish.fallback) clearTimeout(finish.fallback);
                                 if (asError) reject(value); else resolve(value);
                             };
                             finish.handled = false;
                             finish.fallback = setTimeout(() => {
                                 console.warn('QR Code image load timed out, continuing without confirmation.');
                                 finish('timeout');
                             }, 3000);

                             if (isImageLoaded(qrImg)) {
                                 console.log("QR Code image already loaded.");
                                 finish();
                             } else {
                                 console.log("Waiting for QR Code image to load...");
                                 qrImg.addEventListener('load', () => {
                                     console.log("QR Code image loaded.");
                                     finish();
                                 }, { once: true });
                                 qrImg.addEventListener('error', () => {
                                     console.error("QR Code image failed to load.");
                                     finish(new Error('QR Code image load failed'), true);
                                 }, { once: true });
                             }
                         } else {
                             console.warn("QR Code generated, but no img tag found immediately.");
                             resolve('no-qr-img');
                         }
                    } catch (qrError) {
                         console.error("QR Code generation failed:", qrError);
                         qrCodeContainer.innerHTML = `<p class="text-2xs text-red-500">QR Error</p>`;
                         reject(qrError);
                    }
                 } else {
                     console.warn(i18next.t('resultsPage.shareCard.qrError'));
                     reject(new Error('QR Code container or library not found.'));
                }
            });
        }


        function bindCommentFormEvents() {
            if (commentSubmitBound) return;
            const submitButton = document.getElementById('comment-submit-button');
            if (submitButton) {
                submitButton.addEventListener('click', handleCommentSubmit);
                commentSubmitBound = true;
            }
        }

        function clearCommentStatus() {
            const statusEl = document.getElementById('comment-status-message');
            if (!statusEl) return;
            statusEl.classList.add('hidden');
            statusEl.textContent = '';
            statusEl.classList.remove('text-green-600', 'text-red-600');
            if (commentStatusTimer) {
                clearTimeout(commentStatusTimer);
                commentStatusTimer = null;
            }
        }

        function showCommentStatus(message, isError = false) {
            const statusEl = document.getElementById('comment-status-message');
            if (!statusEl) return;
            if (commentStatusTimer) {
                clearTimeout(commentStatusTimer);
                commentStatusTimer = null;
            }
            if (!message) {
                clearCommentStatus();
                return;
            }
            statusEl.textContent = message;
            statusEl.classList.remove('hidden', 'text-green-600', 'text-red-600');
            statusEl.classList.add(isError ? 'text-red-600' : 'text-green-600');
            commentStatusTimer = setTimeout(() => {
                statusEl.classList.add('hidden');
                statusEl.textContent = '';
                statusEl.classList.remove('text-green-600', 'text-red-600');
                commentStatusTimer = null;
            }, 4000);
        }

        function isAdminUser() {
            const role = currentAuthUser?.db_role || commentState.currentUserRole;
            return role === 'admin' || role === 'super_admin';
        }

        function updateCommentFormState() {
            const sectionEl = document.getElementById('comments-section');
            if (!sectionEl) return;
            if (!ratingId) {
                sectionEl.classList.add('hidden');
                return;
            }
            sectionEl.classList.remove('hidden');

            const loginPrompt = document.getElementById('comment-login-prompt');
            const mutedMessage = document.getElementById('comment-muted-message');
            const formContainer = document.getElementById('comment-form-container');
            const textarea = document.getElementById('comment-input');
            const submitButton = document.getElementById('comment-submit-button');

            if (!currentAuthUser) {
                if (loginPrompt) loginPrompt.classList.remove('hidden');
                if (mutedMessage) mutedMessage.classList.add('hidden');
                if (formContainer) formContainer.classList.add('hidden');
                if (textarea) {
                    textarea.disabled = true;
                    textarea.value = '';
                }
                if (submitButton) submitButton.disabled = true;
                return;
            }

            if (loginPrompt) loginPrompt.classList.add('hidden');
            if (formContainer) {
                formContainer.classList.remove('hidden');
                formContainer.classList.toggle('opacity-60', commentState.currentUserMuted);
            }
            const isMuted = !!commentState.currentUserMuted;
            if (textarea) textarea.disabled = isMuted;
            if (submitButton) submitButton.disabled = isMuted;
            if (mutedMessage) mutedMessage.classList.toggle('hidden', !isMuted);
        }

        function renderCommentsSection() {
            const sectionEl = document.getElementById('comments-section');
            if (!sectionEl) return;
            if (!ratingId) {
                sectionEl.classList.add('hidden');
                return;
            }

            const listEl = document.getElementById('comments-list');
            const emptyEl = document.getElementById('comments-empty');
            const countEl = document.getElementById('comments-count');

            if (countEl) {
                const count = commentState.comments?.length || 0;
                countEl.textContent = i18next.t('resultsPage.comments.count', { count });
            }

            if (!listEl) return;
            listEl.innerHTML = '';

            if (!commentState.comments || commentState.comments.length === 0) {
                if (emptyEl) emptyEl.classList.remove('hidden');
                return;
            }

            if (emptyEl) emptyEl.classList.add('hidden');

            const adminCanMute = isAdminUser();

            commentState.comments.forEach(comment => {
                const item = document.createElement('div');
                item.className = 'border border-gray-200 rounded-lg p-4 bg-gray-50';

                const header = document.createElement('div');
                header.className = 'flex flex-wrap items-center justify-between gap-2';

                const meta = document.createElement('div');
                meta.className = 'flex flex-wrap items-center gap-2 text-sm text-gray-600';

                const authorSpan = document.createElement('span');
                authorSpan.className = 'font-semibold text-gray-700';
                const authorDisplay = comment.userNickname || comment.userEmail || comment.userId || i18next.t('common.anonymous');
                authorSpan.textContent = authorDisplay;
                meta.appendChild(authorSpan);

                const dotSpan = document.createElement('span');
                dotSpan.className = 'text-gray-300';
                dotSpan.textContent = '•';
                meta.appendChild(dotSpan);

                const timeSpan = document.createElement('span');
                timeSpan.className = 'text-xs text-gray-500';
                timeSpan.textContent = formatCommentTimestamp(comment.createdAt);
                meta.appendChild(timeSpan);

                const isMuted = commentState.mutedUserIds.has(comment.userId);
                if (isMuted) {
                    const mutedBadge = document.createElement('span');
                    mutedBadge.className = 'px-2 py-0.5 text-xs font-medium rounded-full bg-red-100 text-red-600';
                    mutedBadge.textContent = i18next.t('resultsPage.comments.mutedBadge');
                    meta.appendChild(mutedBadge);
                }

                header.appendChild(meta);

                if (adminCanMute && comment.userId) {
                    const actions = document.createElement('div');
                    actions.className = 'flex items-center gap-2';
                    const muteButton = document.createElement('button');
                    muteButton.className = `px-2 py-1 text-xs font-semibold rounded text-white transition ${isMuted ? 'bg-green-500 hover:bg-green-600' : 'bg-red-500 hover:bg-red-600'}`;
                    muteButton.textContent = i18next.t(isMuted ? 'resultsPage.comments.unmute' : 'resultsPage.comments.mute');
                    muteButton.addEventListener('click', (event) => {
                        event.preventDefault();
                        event.stopPropagation();
                        toggleMuteUser(comment.userId, !isMuted, authorDisplay);
                    });
                    actions.appendChild(muteButton);
                    header.appendChild(actions);
                }

                item.appendChild(header);

                const contentParagraph = document.createElement('p');
                contentParagraph.className = 'mt-3 text-sm text-gray-700 whitespace-pre-wrap break-words';
                contentParagraph.textContent = comment.content || '';
                item.appendChild(contentParagraph);

                listEl.appendChild(item);
            });
        }

        function formatCommentTimestamp(isoString) {
            if (!isoString) return '';
            try {
                const locale = i18next.language || 'zh';
                const date = new Date(isoString);
                if (Number.isNaN(date.getTime())) return isoString;
                return date.toLocaleString(locale, {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch (e) {
                return isoString;
            }
        }

        async function loadCommentsSection() {
            const sectionEl = document.getElementById('comments-section');
            if (!sectionEl) return;
            if (!ratingId) {
                sectionEl.classList.add('hidden');
                return;
            }

            bindCommentFormEvents();

            try {
                const apiUrl = new URL('/api/comments', window.location.origin);
                apiUrl.searchParams.set('ratingId', ratingId);
                const headers = {};
                const token = sessionStorage.getItem('accessToken');
                if (token) headers['Authorization'] = `Bearer ${token}`;

                const response = await fetch(apiUrl, { headers });
                if (!response.ok) {
                    let errorText = `Load failed: ${response.status}`;
                    try {
                        const err = await response.json();
                        errorText = err.error || errorText;
                    } catch (e) { /* ignore */ }
                    throw new Error(errorText);
                }

                const data = await response.json();
                commentState.comments = Array.isArray(data.comments) ? data.comments : [];
                commentState.mutedUserIds = new Set((data.mutedUserIds || []).filter(Boolean));
                commentState.currentUserMuted = data.currentUser?.muted ?? false;
                commentState.currentUserId = data.currentUser?.id ?? (currentAuthUser?.sub ?? null);
                commentState.currentUserRole = data.currentUser?.role ?? (currentAuthUser?.db_role ?? 'general');
                renderCommentsSection();
                updateCommentFormState();
            } catch (error) {
                console.error('[results.html] Failed to load comments:', error);
                showCommentStatus(i18next.t('resultsPage.comments.loadFailed', { msg: error.message }), true);
            }
        }

        async function handleCommentSubmit(event) {
            event.preventDefault();
            if (!ratingId) return;
            if (!currentAuthUser) {
                showCommentStatus(i18next.t('common.loginRequired'), true);
                updateCommentFormState();
                return;
            }
            if (commentState.currentUserMuted) {
                showCommentStatus(i18next.t('resultsPage.comments.muted'), true);
                return;
            }

            const textarea = document.getElementById('comment-input');
            const submitButton = document.getElementById('comment-submit-button');
            if (!textarea || !submitButton) return;

            const content = (textarea.value || '').trim();
            if (!content) {
                showCommentStatus(i18next.t('resultsPage.comments.validation'), true);
                return;
            }

            const token = sessionStorage.getItem('accessToken');
            if (!token) {
                showCommentStatus(i18next.t('common.loginRequired'), true);
                updateCommentFormState();
                return;
            }

            submitButton.disabled = true;
            submitButton.classList.add('cursor-not-allowed', 'opacity-70');

            try {
                const response = await fetch('/api/comments', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({ ratingId, content })
                });
                if (!response.ok) {
                    let errorText = `Submit failed: ${response.status}`;
                    try {
                        const err = await response.json();
                        errorText = err.error || errorText;
                    } catch (e) { /* ignore */ }
                    throw new Error(errorText);
                }

                textarea.value = '';
                await loadCommentsSection();
                updateCommentFormState();
                showCommentStatus(i18next.t('resultsPage.comments.postSuccess'), false);
            } catch (error) {
                console.error('[results.html] Failed to submit comment:', error);
                showCommentStatus(i18next.t('resultsPage.comments.postFailed', { msg: error.message }), true);
            } finally {
                submitButton.disabled = commentState.currentUserMuted;
                submitButton.classList.remove('cursor-not-allowed', 'opacity-70');
            }
        }

        async function toggleMuteUser(targetUserId, shouldMute, displayName = '') {
            if (!targetUserId) return;
            const token = sessionStorage.getItem('accessToken');
            if (!token) {
                showCommentStatus(i18next.t('common.loginRequired'), true);
                return;
            }

            const confirmKey = shouldMute ? 'resultsPage.comments.muteConfirm' : 'resultsPage.comments.unmuteConfirm';
            const confirmMessage = i18next.t(confirmKey, { user: displayName || '' });
            if (confirmMessage && !confirm(confirmMessage)) return;

            try {
                const response = await fetch('/api/comments', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({ action: shouldMute ? 'mute' : 'unmute', targetUserId })
                });
                if (!response.ok) {
                    let errorText = `Update failed: ${response.status}`;
                    try {
                        const err = await response.json();
                        errorText = err.error || errorText;
                    } catch (e) { /* ignore */ }
                    throw new Error(errorText);
                }

                await loadCommentsSection();
                updateCommentFormState();
                showCommentStatus(i18next.t(shouldMute ? 'resultsPage.comments.muteSuccess' : 'resultsPage.comments.unmuteSuccess'), false);
            } catch (error) {
                console.error('[results.html] Failed to update mute status:', error);
                showCommentStatus(i18next.t('resultsPage.comments.muteFailed', { msg: error.message }), true);
            }
        }


        // Renders the main content of the results page using the provided data
        function renderPageContent(data) {
             console.log("[results.html renderPageContent] Received data:", JSON.stringify(data).substring(0, 300) + '...'); // Log received data start
            if (!data || !i18next.isInitialized) {
                 console.error("[results.html renderPageContent] No data received or i18n not ready.");
                 return; // Exit if no data or i18n not ready
            }

            // Destructure with defaults
            const { cigarInfo = {}, cigarReview, normalizedScore, isDraft, selectedFlavors = [] } = data;
            const rawFinalGrade = data.finalGrade ?? (data.finalGrade_grade ? { grade: data.finalGrade_grade, name_cn: data.finalGrade_name_cn } : null);
            const resolvedFinalGrade = resolveFinalGrade(rawFinalGrade, normalizedScore);
            data.finalGrade = resolvedFinalGrade;
            const title = data.title || i18next.t('common.noTitle');
            const reviewerName = data.userNickname || data.userEmail || null;
            const userNickname = reviewerName || i18next.t('common.anonymous');

            // --- ADDED LOGS ---
            console.log("[results.html renderPageContent] Trying to render:");
            console.log("  > Title:", title);
            console.log("  > User Nickname:", userNickname);
            console.log("  > Cigar Info:", JSON.stringify(cigarInfo));
            console.log("  > Cigar Review (start):", (cigarReview || '').substring(0, 50) + '...');
            console.log("  > Selected Flavors:", JSON.stringify(selectedFlavors));
            console.log("  > Normalized Score:", normalizedScore);
            console.log("  > Final Grade:", JSON.stringify(resolvedFinalGrade));
            console.log("  > Is Draft:", isDraft);
            // --- END ADDED LOGS ---

            updatePageMetadata({
                title,
                normalizedScore,
                finalGrade: resolvedFinalGrade,
                cigarInfo,
                userNickname: data.userNickname,
                userEmail: data.userEmail,
                imageUrls: Array.isArray(data.imageUrls) ? data.imageUrls : [],
            });

            // --- ADDED: Get references to DOM elements ---
             const userNicknameEl = document.getElementById('user-nickname');
             const ratingTitleEl = document.getElementById('rating-title');
             const cigarNameEl = document.getElementById('cigar-name');
             const cigarSizeEl = document.getElementById('cigar-size');
             const cigarOriginEl = document.getElementById('cigar-origin');
             const reviewContainerEl = document.getElementById('cigar-review-container');
             const flavorsContainerEl = document.getElementById('selected-flavors-container');
             const flavorsDisplayEl = document.getElementById('flavors-display');
             const scoreSectionEl = document.getElementById('score-section');
             const narrativeSummaryContainerEl = document.getElementById('narrative-summary-container');
             const summaryContainerEl = document.getElementById('summary-container');
             const narrativeDetailsEl = document.getElementById('narrative-summary-details');
             const summaryDetailsEl = document.getElementById('summary-details');
             const saveButtonContainerEl = document.getElementById('save-button-container');
             // --- END ADDED ---

            // --- Robust check for essential data before proceeding ---
             if (normalizedScore === undefined || !cigarInfo) {
                 console.error("[results.html renderPageContent] Essential data missing: score or cigarInfo.", {normalizedScore, cigarInfo});
                 if (scoreSectionEl) scoreSectionEl.innerHTML = `<p class="text-red-500">${i18next.t('errors.missingEssentialData')}</p>`;
                 // Hide other sections that depend on this data
                 if (narrativeDetailsEl) narrativeDetailsEl.style.display = 'none';
                 if (summaryDetailsEl) summaryDetailsEl.style.display = 'none';
                 // Try to populate basic info anyway
                 if (userNicknameEl) userNicknameEl.textContent = userNickname;
                 if (ratingTitleEl) ratingTitleEl.textContent = title;
                 if (cigarNameEl) cigarNameEl.textContent = cigarInfo?.name ?? i18next.t('common.unknown');
                 if (cigarSizeEl) cigarSizeEl.textContent = cigarInfo?.size ?? i18next.t('common.unknown');
                 if (cigarOriginEl) cigarOriginEl.textContent = cigarInfo?.origin ?? i18next.t('common.unknown');
                 if (reviewContainerEl) reviewContainerEl.innerHTML = `<p class="text-gray-400 italic">${i18next.t('common.noReview')}</p>`;
                 if (flavorsContainerEl) flavorsContainerEl.classList.add('hidden');
                 if (saveButtonContainerEl) saveButtonContainerEl.style.display = 'none'; // Don't show save if data is bad
                 return; // Stop rendering here
             }


            // --- Check finalGrade specifically ---
            if (!resolvedFinalGrade || typeof resolvedFinalGrade !== 'object' || !resolvedFinalGrade.grade || !resolvedFinalGrade.nameKey || !resolvedFinalGrade.color) {
                console.error("[results.html renderPageContent] finalGrade data is missing or incomplete.", resolvedFinalGrade);
                 if (scoreSectionEl) scoreSectionEl.innerHTML = `<p class="text-red-500">${i18next.t('resultsPage.scoreCalculationFailed')}</p>`;
                 if (narrativeSummaryContainerEl) narrativeSummaryContainerEl.innerHTML = `<p class="text-red-500 italic">${i18next.t('resultsPage.narrativeGenFailed')}</p>`;
                 if (summaryContainerEl) summaryContainerEl.innerHTML = '';
                 // Hide details sections
                 if (narrativeDetailsEl) narrativeDetailsEl.style.display = 'none';
                 if (summaryDetailsEl) summaryDetailsEl.style.display = 'none';
                 // Populate basic info
                 if (userNicknameEl) userNicknameEl.textContent = userNickname;
                 if (ratingTitleEl) ratingTitleEl.textContent = title;
                 if (cigarNameEl) cigarNameEl.textContent = cigarInfo?.name ?? i18next.t('common.unknown');
                 if (cigarSizeEl) cigarSizeEl.textContent = cigarInfo?.size ?? i18next.t('common.unknown');
                 if (cigarOriginEl) cigarOriginEl.textContent = cigarInfo?.origin ?? i18next.t('common.unknown');
                 if (reviewContainerEl) reviewContainerEl.innerHTML = (cigarReview && cigarReview.trim() && cigarReview !== i18next.t('common.noReview')) ? `<p>${cigarReview.replace(/\n/g, '<br>')}</p>` : `<p class="text-gray-400 italic">${i18next.t('common.noReview')}</p>`;
                 if (flavorsContainerEl) {
                     if (selectedFlavors.length > 0) {
                        if (flavorsDisplayEl) flavorsDisplayEl.innerHTML = selectedFlavors.map(flavorKey => `<span class="flavor-tag">${i18next.t(flavorKey) || flavorKey}</span>`).join('');
                        flavorsContainerEl.classList.remove('hidden');
                     } else { flavorsContainerEl.classList.add('hidden'); }
                 }
                 // Save button logic remains
                 if (saveButtonContainerEl) saveButtonContainerEl.style.display = (currentAuthUser && isDraft) ? 'block' : 'none';
            } else { // Grade data IS valid, proceed normally
                 const gradeName = i18next.t(resolvedFinalGrade.nameKey);
                 if (userNicknameEl) userNicknameEl.textContent = userNickname;
                 if (ratingTitleEl) ratingTitleEl.textContent = title;
                 if (cigarNameEl) cigarNameEl.textContent = cigarInfo?.name ?? i18next.t('common.unknown');
                 if (cigarSizeEl) cigarSizeEl.textContent = cigarInfo?.size ?? i18next.t('common.unknown');
                 if (cigarOriginEl) cigarOriginEl.textContent = cigarInfo?.origin ?? i18next.t('common.unknown');
                 if (reviewContainerEl) reviewContainerEl.innerHTML = (cigarReview && cigarReview.trim() && cigarReview !== i18next.t('common.noReview')) ? `<p>${cigarReview.replace(/\n/g, '<br>')}</p>` : `<p class="text-gray-400 italic">${i18next.t('common.noReview')}</p>`;
                 if (flavorsContainerEl) {
                     if (selectedFlavors.length > 0) {
                         if(flavorsDisplayEl) flavorsDisplayEl.innerHTML = selectedFlavors.map(flavorKey => `<span class="flavor-tag">${i18next.t(flavorKey) || flavorKey}</span>`).join('');
                         flavorsContainerEl.classList.remove('hidden');
                     } else { flavorsContainerEl.classList.add('hidden'); }
                 }
                 if (scoreSectionEl) renderScoreSection(scoreSectionEl, normalizedScore, { ...resolvedFinalGrade, name: gradeName });

                 // Check if config and ratings exist for detailed summaries
                 const hasFullData = data.config && data.ratings;
                 [narrativeDetailsEl, summaryDetailsEl].forEach(el => { if (el) el.style.display = hasFullData ? 'block' : 'none'; });

                 if (hasFullData) {
                    if (narrativeSummaryContainerEl) narrativeSummaryContainerEl.innerHTML = generateNarrativeSummary(cigarInfo, data.config, data.ratings, { ...resolvedFinalGrade, name: gradeName }, selectedFlavors);
                    if (summaryContainerEl) renderSummary(summaryContainerEl, data.config, data.ratings);
                 } else {
                     console.warn("[results.html renderPageContent] Missing full data (config/ratings), hiding narrative and summary sections.");
                 }
                 // Populate share card (only if grade data was valid)
                 populateShareCard(data);
                 // Save button logic remains
                 if (saveButtonContainerEl) saveButtonContainerEl.style.display = (currentAuthUser && isDraft) ? 'block' : 'none';
            }
        }

        // --- Initialization on page load ---
        window.onload = async function() {
            const errorContainer = document.getElementById('error-container');
            const mainContent = document.getElementById('main-content');
            const loadingIndicator = document.getElementById('loading-indicator');

            try {
                 await initI18n();
                 updateContent();

                 const urlParams = new URLSearchParams(window.location.search);
                 const code = urlParams.get('code');
                 ratingId = urlParams.get('ratingId'); // Check if loading saved rating by ID

                 let user = code ? await handleOidcCallback(code) : await validateSessionAndGetUser();
                 currentAuthUser = user;
                 renderLoginStatus(currentAuthUser);
                 renderLanguageSwitcher();
                 bindCommentFormEvents();
                 updateCommentFormState();

                 loadingIndicator.classList.remove('hidden');

                 // Determine if loading from ID or sessionStorage
                 if (ratingId) { // Load saved rating from API
                     console.log("[results.html onload] Loading rating from API with ID:", ratingId);
                     const token = sessionStorage.getItem('accessToken');
                     const apiUrl = new URL(`/api/ratings?id=${ratingId}`, window.location.origin);
                     // Allow anonymous fetch if no token (API handles public read)
                     const fetchOptions = token ? { headers: { 'Authorization': `Bearer ${token}` } } : {};
                     const response = await fetch(apiUrl, fetchOptions);
                     if (!response.ok) {
                         let errorText = i18next.t('errors.loadRatingFailed', { status: response.status });
                         try { const err = await response.json(); errorText = err.error || errorText; } catch(e){}
                         throw new Error(errorText);
                     }
                     resultsData = await response.json();
                     resultsData.isDraft = false; // Data from API is never a draft
                     resultsData = normalizeResultsData(resultsData);
                     console.log("[results.html onload] Loaded data from API:", JSON.stringify(resultsData).substring(0, 300) + '...');
                 } else { // Load draft from sessionStorage
                     console.log("[results.html onload] Loading rating from sessionStorage");
                     const storedData = sessionStorage.getItem('cigarRatingResults');
                     if (!storedData) throw new Error(i18next.t('errors.noRatingDataFound'));
                     try {
                         resultsData = JSON.parse(storedData);
                         resultsData = normalizeResultsData(resultsData);
                         // *** FIX: REMOVED resultsData.isDraft = true; ***
                         // The 'isDraft' flag (true from rate.html, false from history.html/index.html)
                         // is now correctly loaded from the stored data.
                         ratingId = resultsData.ratingId; // Might be null if not saved yet
                         console.log("[results.html onload] Parsed data from sessionStorage:", JSON.stringify(resultsData).substring(0, 300) + '...');
                     } catch(parseError) {
                         console.error("[results.html onload] Error parsing sessionStorage data:", parseError);
                         throw new Error(i18next.t('errors.invalidSessionData'));
                     }
                 }

                 // Basic validation after loading data
                 if (!resultsData || resultsData.normalizedScore === undefined || !resultsData.cigarInfo) {
                     console.error("[results.html onload] Essential data missing after loading!", resultsData);
                     throw new Error(i18next.t('errors.missingEssentialData'));
                 }

                 if (!ratingId && resultsData?.id) {
                     ratingId = resultsData.id;
                 }

                 // Render UI elements
                 await initSwipers(resultsData.imageUrls || []); // Initialize image slider
                 renderPageContent(resultsData); // Render main content sections

                 // Generate QR and attempt share image AFTER main content is rendered
                 await generateQRCode();
                 tryAutoGenerateShareImage();
                 await loadCommentsSection();

                 loadingIndicator.classList.add('hidden'); // Hide loading indicator
                 mainContent.classList.remove('opacity-0'); // Show main content

            } catch (e) { // Catch any error during initialization
                 loadingIndicator.classList.add('hidden');
                 const errorTitle = i18next.t('errors.pageLoadError');
                 const backLinkText = i18next.t('common.backToCommunity');
                 const rateLinkText = i18next.t('nav.rate');
                 errorContainer.innerHTML = `<p class="font-bold text-center">${errorTitle}: ${e.message}</p> <div class="mt-4 text-center space-x-4"> <a href="index.html" class="text-indigo-600 underline">${backLinkText}</a> <a href="rate.html" class="text-green-600 underline">${rateLinkText}</a> </div>`;
                 errorContainer.classList.remove('hidden');
                 mainContent.classList.add('opacity-0'); // Keep main content hidden on error
                 const commentsSection = document.getElementById('comments-section');
                 if (commentsSection) commentsSection.classList.add('hidden');
                 console.error("[results.html onload] Initialization error:", e);
            }
        };

        window.addEventListener('beforeunload', () => {
            if (shareImageObjectUrl) {
                URL.revokeObjectURL(shareImageObjectUrl);
                shareImageObjectUrl = null;
            }
            if (shareImageRetryTimer) {
                clearTimeout(shareImageRetryTimer);
                shareImageRetryTimer = null;
            }
        });

        // --- Rendering Utilities ---

        // Generates the narrative summary text
        function generateNarrativeSummary(cigarInfo, config, ratings, finalGrade, selectedFlavors) {
            if (!config || !ratings) return `<p class="text-gray-500 italic">${i18next.t('errors.noNarrativeData')}</p>`;
            const { origin = i18next.t('common.unknown'), name = i18next.t('common.unknown'), size = i18next.t('common.unknown') } = cigarInfo || {};
            let summary = `<p>${i18next.t('resultsPage.narrative.part1', { origin, name, size })}`;
            let observations = [];
            (config.ratingCriteria || []).forEach(category => {
                (category.criteriaList || []).forEach(criterion => {
                    let id = null;
                    if (category.categoryKey && criterion.nameKey) { id = `${category.categoryKey}-${criterion.nameKey}`; }
                    else if (category.category && criterion.name) { id = `${category.category}-${criterion.name}`; } // Fallback for older data?
                    if (id) {
                        const idx = ratings[id];
                        if (idx !== undefined && criterion.options?.[idx]) {
                            const opt = criterion.options[idx];
                            // Translate keys, fallback to original text if translation missing
                            const critTxt = i18next.t(criterion.nameKey || criterion.name, criterion.name || '?');
                            const optTxt = i18next.t(opt.descriptionKey || opt.description, opt.description || '?');
                            observations.push(i18next.t('resultsPage.narrative.observation', { criterion: critTxt, option: optTxt }));
                        }
                    } else { console.warn("Could not determine ID for criterion in generateNarrativeSummary:", {category, criterion}); }
                });
            });
            if (observations.length > 0) { summary += ` ${i18next.t('resultsPage.narrative.part2', { observations: observations.join('；') })}`; }
            else { summary += ` ${i18next.t('resultsPage.narrative.noObservations')}`; }
            if (selectedFlavors.length > 0) { const translated = selectedFlavors.map(k => i18next.t(k) || k).join(', '); summary += ` ${i18next.t('resultsPage.narrative.part3', { flavors: translated })}`; }
            // Use finalGrade object passed to the function
            const gradeName = (finalGrade && finalGrade.name) ? finalGrade.name : i18next.t('common.unrated');
            const gradeLetter = (finalGrade && finalGrade.grade) ? finalGrade.grade : '?';
            const hierarchy = GRADING_SCALE.map(g => `${g.grade}(${i18next.t(g.nameKey)})`).join(', ');
            summary += ` ${i18next.t('resultsPage.narrative.part4', { grade: gradeLetter, gradeName: gradeName, hierarchy: hierarchy })}`;
            summary += `</p>`;
            return summary;
        }

        // Renders the detailed rating summary section
        function renderSummary(container, config, ratings) {
            if (!container || !config || !ratings) { container.innerHTML = `<p class="text-gray-500 italic">${i18next.t('errors.noSummaryData')}</p>`; return; }
            let summaryHtml = (config.ratingCriteria || []).map(category => {
                const criteriaHtml = (category.criteriaList || []).map(criterion => {
                    let id = null;
                    if (category.categoryKey && criterion.nameKey) { id = `${category.categoryKey}-${criterion.nameKey}`; }
                    else if (category.category && criterion.name) { id = `${category.category}-${criterion.name}`; } // Fallback
                    if (id) {
                        const idx = ratings[id];
                        if (idx !== undefined && criterion.options?.[idx]) {
                            const opt = criterion.options[idx];
                            // Translate keys, fallback to original text
                            const critTxt = i18next.t(criterion.nameKey || criterion.name, criterion.name || '?');
                            const optTxt = i18next.t(opt.descriptionKey || opt.description, opt.description || '?');
                            return `<li><strong>${critTxt}:</strong> ${optTxt}</li>`;
                        }
                    } else { console.warn("Could not determine ID for criterion in renderSummary:", {category, criterion}); }
                    return '';
                }).join('');
                if (criteriaHtml.trim()) {
                    // Translate category key, fallback to original text
                    const catTitle = i18next.t(category.categoryKey || category.category, category.category || '?');
                    return `<h4 class="font-semibold mt-4 mb-1 text-gray-700">${catTitle}</h4><ul class="list-disc list-inside space-y-1 text-sm">${criteriaHtml}</ul>`;
                } return '';
            }).join('');
            container.innerHTML = summaryHtml || `<p>${i18next.t('resultsPage.summary.noItems')}</p>`;
        }
        // --- End Rendering Utilities ---
        // --- Rendering Utilities (Continued) ---

        // Generates the score range string
        function getScoreRange(gradeCode) {
            const index = GRADING_SCALE.findIndex(g => g.grade === gradeCode);
            if (index === -1) return '';
            const min = GRADING_SCALE[index].min_score;
            if (index === 0) return `${min}-100`; // Highest grade range
            const max = GRADING_SCALE[index - 1].min_score - 0.01; // Max is just below the next higher grade's min
            return `${min.toFixed(0)}-${max.toFixed(2)}`;
        }

        // Returns Tailwind CSS classes for a grade color
        function getGradeStyles(color) {
            const stylesMap = {
                'gold': { textColor: 'text-yellow-800', bgColor: 'bg-yellow-400' },
                'indigo': { textColor: 'text-indigo-800', bgColor: 'bg-indigo-300' },
                'purple': { textColor: 'text-purple-800', bgColor: 'bg-purple-300' },
                'blue': { textColor: 'text-blue-800', bgColor: 'bg-blue-300' },
                'green': { textColor: 'text-green-800', bgColor: 'bg-green-300' },
                'gray': { textColor: 'text-gray-800', bgColor: 'bg-gray-300' },
                'orange': { textColor: 'text-orange-800', bgColor: 'bg-orange-300' },
                'red': { textColor: 'text-red-800', bgColor: 'bg-red-300' }
            };
            return stylesMap[color] || stylesMap['gray']; // Default to gray if color not found
        }

         // Renders the score section
         function renderScoreSection(container, score, grade) {
             // Robust check: Ensure grade object is valid and has expected properties
             if (!container || !grade || typeof grade !== 'object' || !grade.grade || !grade.name || !grade.color || !i18next.isInitialized) {
                 console.error("[results.html renderScoreSection] Invalid grade object received or i18n not ready:", grade);
                 container.innerHTML = `<p class="text-red-500">${i18next.t('resultsPage.scoreCalculationFailed')}</p>`;
                 return;
             }
             const styles = getGradeStyles(grade.color);
             // Main score and grade name display
             const scoreHtml = `
                <div>
                    <p class="text-xl font-bold text-yellow-500 mb-1">${i18next.t('resultsPage.scoreSectionTitle')}</p>
                    <p class="text-7xl font-black ${styles.textColor}">${score?.toFixed(2) ?? '?.??'}</p>
                    <div class="mt-2 text-3xl font-black ${styles.textColor}">${grade.name ?? i18next.t('common.unrated')}</div>
                </div>`;
             // Grading scale legend
             const scaleHtml = GRADING_SCALE.map(g => {
                 const gs = getGradeStyles(g.color);
                 const isCurrentGrade = g.grade === grade.grade;
                 return `
                 <div class="flex items-center p-1 rounded ${isCurrentGrade ? 'bg-gray-100' : ''}">
                     <div class="w-5 h-5 rounded-full flex items-center justify-center font-bold text-xs ${gs.bgColor} ${gs.textColor} mr-2">${g.grade}</div>
                     <div class="flex-grow ${isCurrentGrade ? 'font-semibold' : ''} ${gs.textColor}">${i18next.t(g.nameKey)}</div>
                     <div class="font-mono text-xs text-gray-500 ml-2">${getScoreRange(g.grade)}</div>
                 </div>`;
             }).join('');
             // Combine into the container
             container.innerHTML = `
                 <div class="w-full md:w-1/3">${scoreHtml}</div>
                 <div class="w-full md:w-2/3 border-t md:border-t-0 md:border-l border-gray-200 pt-4 md:pt-0 md:pl-6">
                     <div class="space-y-1">${scaleHtml}</div>
                 </div>`;
         }
        // --- End Rendering Utilities ---

    </script>
</body>
</html>

